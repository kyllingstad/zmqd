<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8">
	<title>zmqd - zmqd documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- styles -->
	<link href="bootDoc/assets/css/bootstrap.css" rel="stylesheet">
	<style type="text/css">
		body {
		padding-top: 60px;
		padding-bottom: 40px;
		}
		.sidebar-nav {
		padding: 9px 0;
		}
	</style>
	<link href="bootDoc/assets/css/bootstrap-responsive.css" rel="stylesheet">
	<link href="bootDoc/bootdoc.css" rel="stylesheet">

	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- fav and touch icons -->
	<link rel="shortcut icon" href="bootDoc/assets/ico/favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="bootDoc/assets/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="bootDoc/assets/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="bootDoc/assets/ico/apple-touch-icon-57-precomposed.png">
	
	<!-- Introduce DDoc settings required by JavaScript -->
	<script type="text/javascript">
		var Title = 'zmqd';
		var SourceRepository = 'https://github.com/kyllingstad/zmqd/tree/master/src';
		var PackageSeparator = '.';
	</script>
	
	<style type="text/css">
		.ddoc-icon-variable { background-image: url('bootDoc/ddoc-icons/var.png'); }
		.ddoc-icon-function { background-image: url('bootDoc/ddoc-icons/func.png'); }
		.ddoc-icon-property { background-image: url('bootDoc/ddoc-icons/property.png'); }
		.ddoc-icon-struct { background-image: url('bootDoc/ddoc-icons/struct.png'); }
		.ddoc-icon-class { background-image: url('bootDoc/ddoc-icons/class.png'); }
		.ddoc-icon-enum { background-image: url('bootDoc/ddoc-icons/enum.png'); }
		.ddoc-icon-template { background-image: url('bootDoc/ddoc-icons/template.png'); }
	</style>
	</head>

	<body>
	<!--
	JavaScript reaps the module list from this element.
	This is required for the MODULES macro to be reusable
	in a noscript element later.
	-->
	<ul id="module-list-source" class="hidden">
		
	<li class="sidebar-list-entry tree-leaf"><a href="zmqd.html" title="zmqd"><i class="icon-th"></i>zmqd</a></li>
	</ul>
	
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container-fluid">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="index.html">zmqd</a>
				<div class="nav-collapse">
					<ul class="nav">
						<li class="active"><a href="index.html">Reference</a></li>
					</ul>
					
					<form id="gotosymbol" class="navbar-search pull-left hidden">
						<input type="text" class="search-query" placeholder="Go to symbol in zmqd" data-provide="typeahead" data-items="4">
					</form>
					
					<p class="navbar-text pull-right"><a href="https://github.com/kyllingstad/zmqd">Github Page</a></p>
				</div><!--/.nav-collapse -->
			</div>
		</div>
	</div>

	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span2">
				<div class="well sidebar-nav">
				<ul class="nav nav-list">
					<li id="module-list" class="nav-header sidebar-list-entry">Modules<li>
					<noscript>
						
	<li class="sidebar-list-entry tree-leaf"><a href="zmqd.html" title="zmqd"><i class="icon-th"></i>zmqd</a></li>
					</noscript>
					<li id="symbol-list" class="nav-header sidebar-list-entry hidden">zmqd</li>
				</ul>
				</div><!--/.well -->
			</div><!--/span-->
			
			<div class="span10">
				<div class="row-fluid">
					<div class="span11">
						<ul id="module-breadcrumb" class="breadcrumb">
							<noscript><h1>zmqd</h1></noscript>
						</ul>
						
					</div>
					<div class="span1 offset11">
						<a href="index.html"><img src="bootDoc/assets/img/icon-github.png" alt="zmqd"/></a>
					</div>
				</div>
				<div id="declaration-list">
					<!-- Generated by Ddoc from ../src/zmqd.d -->
<dl><p>A thin wrapper around the low-level C API of the <a href="http://zeromq.org">&#x2205;MQ</a>
messaging framework, for the <a href="http://dlang.org">D programming language</a>.
</p>
<p>Most functions in this module have a one-to-one relationship with functions
in the underlying C API.  Some adaptations have been made to make the API
safer, easier and more pleasant to use; most importantly:
<ul>    <li>        Errors are signalled by means of exceptions rather than return
        codes.  In particular, the <code><a href="#ZmqException">ZmqException</a></code> class provides
        a standard textual message for any error condition, but it also
        provides access to the <code>errno</code> code set by the C function
        that reported the error.</li>
    <li>        Functions are appropriately marked with <code>@safe</code>, <code>pure</code>
        and <code>nothrow</code>, thus facilitating their use in high-level D code.</li>
    <li>        Memory and resources (i.e. contexts, sockets and messages) are
        automatically managed, thus preventing leaks.</li>
    <li>        Context, socket and message options are implemented as properties.</li>
</ul>
The names of functions and types in &#x2205;MQD are very similar to those in
&#x2205;MQ, but they follow the D naming conventions.  Thus, the library should
feel both familiar to &#x2205;MQ users and natural to D users.  A notable
deviation from the C API is that message parts are consistently called
"frames".  For example, <code>zmq_msg_send()</code> becomes <code><span class="symbol-target" id="zmqd">&nbsp;</span><a class="symbol-link" href="#zmqd">zmqd</a>.Frame.send()</code>
and so on.  (Multipart messages were a late addition to &#x2205;MQ, and the "msg"
function names were well established at that point.  The library's
developers have admitted that this is somewhat confusing, and the newer
CZMQ API consistently uses "frame" in function names.)
<br><br>

Due to the close correspondence with the C API, this documentation has
intentionally been kept sparse. There is really no reason to repeat the
contents of the <a href="http://api.zeromq.org/4-0:_start">&#x2205;MQ reference manual</a> here.
Instead, the documentation for each function contains a "Corresponds to"
section that links to the appropriate pages in the &#x2205;MQ reference.  Any
details given in the present documentation mostly concern the D-specific
adaptations that have been made.
<br><br>

Also note that the examples generally only use the INPROC transport.  The
reason for this is that the examples double as unittests, and we want to
avoid firewall troubles and other issues that could arise with the use of
network protocols such as TCP, PGM, etc., and the IPC protocol is not
supported on Windows.  Anyway, they are only short
snippets that demonstrate the syntax; for more comprehensive and realistic
examples, please refer to the <a href="http://zguide.zeromq.org/page:all">&#x2205;MQ Guide</a>.  Many of the examples in the Guide have been translated to
D, and can be found in the
<a href="https://github.com/kyllingstad/zmqd/tree/master/examples"><code>examples</code></a>
subdirectory of the &#x2205;MQD source repository.

</p>
<dt>Version</dt><dd>1.0.0-alpha (compatible with &#x2205;MQ &gt;= 4.0.0)
</dd>
<dt>Authors</dt><dd><a href="http://github.com/kyllingstad">Lars T. Kyllingstad</a>
</dd>
<dt>License</dt><dd>&#x2205;MQD is released under a BSD licence (see LICENCE.txt for details).<br>
    Please refer to the <a href="http://zeromq.org/area:licensing">&#x2205;MQ site</a>
    for details about &#x2205;MQ licensing.
</dd>
</dl>
<hr><div class="row-fluid declaration"><h3>nothrow @safe Tuple!(int, "major", int, "minor", int, "patch") <span class="symbol-target" id="zmqVersion">&nbsp;</span><a class="symbol-link" href="#zmqVersion">zmqVersion</a>();
</h3></div>
<div class="declaration-content"><dl><p>Reports the &#x2205;MQ library version.
</p>
<dt>Returns</dt><dd>A <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> with three integer fields that represent the
    three versioning levels: <code>major</code>, <code>minor</code> and <code>patch</code>.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_version()">zmq_version()</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="SocketType">&nbsp;</span><a class="symbol-link" href="#SocketType">SocketType</a>: int;
</h3></div>
<div class="declaration-content"><dl><p>The various socket types.
</p>
<p>These are described in the <code><a href="http://api.zeromq.org/4-0:zmq_socket()">zmq_socket()</a></code> reference.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="req">&nbsp;</span><a class="symbol-link" href="#req">req</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_REQ</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="rep">&nbsp;</span><a class="symbol-link" href="#rep">rep</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_REP</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="dealer">&nbsp;</span><a class="symbol-link" href="#dealer">dealer</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_DEALER</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="router">&nbsp;</span><a class="symbol-link" href="#router">router</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_ROUTER</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="pub">&nbsp;</span><a class="symbol-link" href="#pub">pub</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_PUB</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="sub">&nbsp;</span><a class="symbol-link" href="#sub">sub</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_SUB</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="xpub">&nbsp;</span><a class="symbol-link" href="#xpub">xpub</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_XPUB</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="xsub">&nbsp;</span><a class="symbol-link" href="#xsub">xsub</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_XSUB</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="push">&nbsp;</span><a class="symbol-link" href="#push">push</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_PUSH</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="pull">&nbsp;</span><a class="symbol-link" href="#pull">pull</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_PULL</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="pair">&nbsp;</span><a class="symbol-link" href="#pair">pair</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_PAIR</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="stream">&nbsp;</span><a class="symbol-link" href="#stream">stream</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_STREAM</code></p>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="Security">&nbsp;</span><a class="symbol-link" href="#Security">Security</a>: int;
</h3></div>
<div class="declaration-content"><dl><p><span class="symbol-target" id="Security">&nbsp;</span><a class="symbol-link" href="#Security">Security</a> mechanisms.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="none">&nbsp;</span><a class="symbol-link" href="#none">none</a></h3></div>
<div class="declaration-content"><dl><p><a href="http://api.zeromq.org/4-0:zmq_null">NULL</a>: No security or confidentiality.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="plain">&nbsp;</span><a class="symbol-link" href="#plain">plain</a></h3></div>
<div class="declaration-content"><dl><p><a href="http://api.zeromq.org/4-0:zmq_plain">PLAIN</a>: Clear-text authentication.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="curve">&nbsp;</span><a class="symbol-link" href="#curve">curve</a></h3></div>
<div class="declaration-content"><dl><p><a href="http://api.zeromq.org/4-0:zmq_curve">CURVE</a>: Secure authentication and confidentiality.</p>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a>;
</h3></div>
<div class="declaration-content"><dl><p>An object that encapsulates a &#x2205;MQ socket.
</p>
<p>A default-initialized <code><span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a></code> is not a valid &#x2205;MQ socket; it
must always be explicitly initialized with a constructor (see
<code><a href="#Socket.this">Socket.this()</a></code>):
<pre class="d_code"><u>Socket</u> s;                     <span class="d_comment">// Not a valid socket yet
</span>s = <u>Socket</u>(SocketType.push);  <span class="d_comment">// ...but now it is.
</span></pre>
This <code>struct</code> is noncopyable, which means that a socket is always
uniquely managed by a single <code><span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a></code> object.  Functions that will
inspect or use the socket, but not take ownership of it, should take
a <code>ref <span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a></code> parameter.  Use <code><a href="http://dlang.org/phobos/std_algorithm.html#.move">std.algorithm.move</a></code> to move
a <code><span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a></code> to a different location (e.g. into a sink function that
takes it by value, or into a new variable).
<br><br>

The socket is automatically closed when the <code><span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a></code> object goes out
of scope.

</p>
<dt>Linger period:</dt><dd>
Note that <span class="symbol-target" id="Socket">&nbsp;</span><a class="symbol-link" href="#Socket">Socket</a> by default sets the socket's linger period to zero.
This deviates from the &#x2205;MQ default (which is an infinite linger period).</dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>@safe this(SocketType <i>type</i>);
<br>@safe this(Context <i>context</i>, SocketType <i>type</i>);
</h3></div>
<div class="declaration-content"><dl><p>Creates a new &#x2205;MQ socket.
</p>
<p>If <code>context</code> is not specified, the default context (as returned
    by <code><a href="#defaultContext">defaultContext()</a></code>) is used.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_socket()">zmq_socket()</a></code></dd>
<dt>Examples</dt><dd>With default <i>context</i>:
<pre class="d_code">
<span class="d_keyword">auto</span> sck = Socket(SocketType.push);
<span class="d_keyword">assert</span> (sck.initialized);
</pre>
</dd><dt>Examples</dt><dd>With explicit <i>context</i>:
<pre class="d_code">
<span class="d_keyword">auto</span> ctx = Context();
<span class="d_keyword">auto</span> sck = Socket(ctx, SocketType.push);
<span class="d_keyword">assert</span> (sck.initialized);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="close">&nbsp;</span><a class="symbol-link" href="#close">close</a>();
</h3></div>
<div class="declaration-content"><dl><p>Closes the &#x2205;MQ socket.
</p>
<p>Note that the socket will be closed automatically upon destruction,
    so it is usually not necessary to call this method manually.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_close()">zmq_close()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> s = Socket(SocketType.pair);
<span class="d_keyword">assert</span> (s.initialized);
s.<u>close</u>();
<span class="d_keyword">assert</span> (!s.initialized);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="bind">&nbsp;</span><a class="symbol-link" href="#bind">bind</a>(const char[] <i>endpoint</i>);
</h3></div>
<div class="declaration-content"><dl><p>Starts accepting incoming connections on <code><i>endpoint</i></code>.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_bind()">zmq_bind()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> s = Socket(SocketType.pub);
s.<u>bind</u>(<span class="d_string">"inproc://zmqd_bind_example"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="unbind">&nbsp;</span><a class="symbol-link" href="#unbind">unbind</a>(const char[] <i>endpoint</i>);
</h3></div>
<div class="declaration-content"><dl><p>Stops accepting incoming connections on <code><i>endpoint</i></code>.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_unbind()">zmq_unbind()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> s = Socket(SocketType.pub);
s.bind(<span class="d_string">"ipc://zmqd_unbind_example"</span>);
<span class="d_comment">// Do some work...
</span>s.<u>unbind</u>(<span class="d_string">"ipc://zmqd_unbind_example"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="connect">&nbsp;</span><a class="symbol-link" href="#connect">connect</a>(const char[] <i>endpoint</i>);
</h3></div>
<div class="declaration-content"><dl><p>Creates an outgoing connection to <code><i>endpoint</i></code>.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_connect()">zmq_connect()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> s = Socket(SocketType.sub);
s.<u>connect</u>(<span class="d_string">"inproc://zmqd_connect_example"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="disconnect">&nbsp;</span><a class="symbol-link" href="#disconnect">disconnect</a>(const char[] <i>endpoint</i>);
</h3></div>
<div class="declaration-content"><dl><p>Disconnects the socket from <code><i>endpoint</i></code>.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_disconnect()">zmq_disconnect()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> s = Socket(SocketType.sub);
s.connect(<span class="d_string">"inproc://zmqd_disconnect_example"</span>);
<span class="d_comment">// Do some work...
</span>s.<u>disconnect</u>(<span class="d_string">"inproc://zmqd_disconnect_example"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="send">&nbsp;</span><a class="symbol-link" href="#send">send</a>(const ubyte[] <i>data</i>, bool <i>more</i> = false);
<br>@safe void <span class="symbol-target" id="send">&nbsp;</span><a class="symbol-link" href="#send">send</a>(const char[] <i>data</i>, bool <i>more</i> = false);
<br>@safe bool <span class="symbol-target" id="trySend">&nbsp;</span><a class="symbol-link" href="#trySend">trySend</a>(const ubyte[] <i>data</i>, bool <i>more</i> = false);
<br>@safe bool <span class="symbol-target" id="trySend">&nbsp;</span><a class="symbol-link" href="#trySend">trySend</a>(const char[] <i>data</i>, bool <i>more</i> = false);
</h3></div>
<div class="declaration-content"><dl><p>Sends a message frame.
</p>
<p><code>send</code> blocks until the frame has been queued on the socket.
    <code>trySend</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the frame was queued on the
    socket.
<br><br>

    The <code><i>more</i></code> parameter specifies whether this is a multipart message
    and there are <i>more</i> frames to follow.
<br><br>

    The <code>char[]</code> overload is a convenience function that simply casts
    the string argument to <code>ubyte[]</code>.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_send()">zmq_send()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the
        case of <code>trySend</code>, and with the <code>ZMQ_SNDMORE</code> flag if
        <code><i>more</i> == <span class="d_keyword">true</span></code>).</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> sck = Socket(SocketType.pub);
sck.send(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>[]) [11, 226, 92]);
sck.send(<span class="d_string">"Hello World!"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="send">&nbsp;</span><a class="symbol-link" href="#send">send</a>(ref Frame <i>msg</i>, bool <i>more</i> = false);
<br>@safe bool <span class="symbol-target" id="trySend">&nbsp;</span><a class="symbol-link" href="#trySend">trySend</a>(ref Frame <i>msg</i>, bool <i>more</i> = false);
</h3></div>
<div class="declaration-content"><dl><p>Sends a message frame.
</p>
<p><code>send</code> blocks until the frame has been queued on the socket.
    <code>trySend</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the frame was queued on the
    socket.
<br><br>

    The <code><i>more</i></code> parameter specifies whether this is a multipart message
    and there are <i>more</i> frames to follow.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_send()">zmq_msg_send()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the
        case of <code>trySend</code>, and with the <code>ZMQ_SNDMORE</code> flag if
        <code><i>more</i> == <span class="d_keyword">true</span></code>).</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> sck = Socket(SocketType.pub);
<span class="d_keyword">auto</span> <b>msg</b> = Frame(12);
<b>msg</b>.data.asString()[] = <span class="d_string">"Hello World!"</span>;
sck.send(<b>msg</b>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="sendConst">&nbsp;</span><a class="symbol-link" href="#sendConst">sendConst</a>(immutable ubyte[] <i>data</i>, bool <i>more</i> = false);
<br>@safe void <span class="symbol-target" id="sendConst">&nbsp;</span><a class="symbol-link" href="#sendConst">sendConst</a>(string <i>data</i>, bool <i>more</i> = false);
<br>@safe bool <span class="symbol-target" id="trySendConst">&nbsp;</span><a class="symbol-link" href="#trySendConst">trySendConst</a>(immutable ubyte[] <i>data</i>, bool <i>more</i> = false);
<br>@safe bool <span class="symbol-target" id="trySendConst">&nbsp;</span><a class="symbol-link" href="#trySendConst">trySendConst</a>(string <i>data</i>, bool <i>more</i> = false);
</h3></div>
<div class="declaration-content"><dl><p>Sends a constant-memory message frame.
</p>
<p><code>sendConst</code> blocks until the frame has been queued on the socket.
    <code>trySendConst</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the frame was queued on the
    socket.
<br><br>

    The <code><i>more</i></code> parameter specifies whether this is a multipart message
    and there are <i>more</i> frames to follow.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_send_const()">zmq_send_const()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the
        case of <code>trySend</code>, and with the <code>ZMQ_SNDMORE</code> flag if
        <code><i>more</i> == <span class="d_keyword">true</span></code>).</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">static</span> <span class="d_keyword">immutable</span> arr = <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>[]) [11, 226, 92];
<span class="d_keyword">auto</span> sck = Socket(SocketType.pub);
sck.sendConst(arr);
sck.sendConst(<span class="d_string">"Hello World!"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe size_t <span class="symbol-target" id="receive">&nbsp;</span><a class="symbol-link" href="#receive">receive</a>(ubyte[] <i>data</i>);
<br>@safe Tuple!(size_t, bool) <span class="symbol-target" id="tryReceive">&nbsp;</span><a class="symbol-link" href="#tryReceive">tryReceive</a>(ubyte[] <i>data</i>);
</h3></div>
<div class="declaration-content"><dl><p>Receives a message frame.
</p>
<p><code>receive</code> blocks until the request can be satisfied, and returns the
    number of bytes in the frame.
    <code>tryReceive</code> performs the operation in non-blocking mode, and returns
    a <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> which contains the size of the frame along
    with a <code>bool</code> value that signifies whether a frame was received.
    (If the latter is <code><span class="d_keyword">false</span></code>, the former is always set to zero.)

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_recv()">zmq_recv()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>tryReceive</code>).</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_comment">// Sender
</span><span class="d_keyword">auto</span> snd = Socket(SocketType.req);
snd.connect(<span class="d_string">"inproc://zmqd_receive_example"</span>);
snd.send(<span class="d_string">"Hello World!"</span>);

<span class="d_comment">// Receiver
</span><span class="d_keyword">import</span> std.string: representation;
<span class="d_keyword">auto</span> rcv = Socket(SocketType.rep);
rcv.bind(<span class="d_string">"inproc://zmqd_receive_example"</span>);
<span class="d_keyword">char</span>[256] buf;
<span class="d_keyword">immutable</span> len  = rcv.receive(buf.representation);
<span class="d_keyword">assert</span> (buf[0 .. len] == <span class="d_string">"Hello World!"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe size_t <span class="symbol-target" id="receive">&nbsp;</span><a class="symbol-link" href="#receive">receive</a>(ref Frame <i>msg</i>);
<br>@safe Tuple!(size_t, bool) <span class="symbol-target" id="tryReceive">&nbsp;</span><a class="symbol-link" href="#tryReceive">tryReceive</a>(ref Frame <i>msg</i>);
</h3></div>
<div class="declaration-content"><dl><p>Receives a message frame.
</p>
<p><code>receive</code> blocks until the request can be satisfied, and returns the
    number of bytes in the frame.
    <code>tryReceive</code> performs the operation in non-blocking mode, and returns
    a <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> which contains the size of the frame along
    with a <code>bool</code> value that signifies whether a frame was received.
    (If the latter is <code><span class="d_keyword">false</span></code>, the former is always set to zero.)

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_recv()">zmq_msg_recv()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>tryReceive</code>).</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_comment">// Sender
</span><span class="d_keyword">auto</span> snd = Socket(SocketType.req);
snd.connect(<span class="d_string">"inproc://zmqd_msg_receive_example"</span>);
snd.send(<span class="d_string">"Hello World!"</span>);

<span class="d_comment">// Receiver
</span><span class="d_keyword">import</span> std.string: representation;
<span class="d_keyword">auto</span> rcv = Socket(SocketType.rep);
rcv.bind(<span class="d_string">"inproc://zmqd_msg_receive_example"</span>);
<span class="d_keyword">auto</span> <b>msg</b> = Frame();
rcv.receive(<b>msg</b>);
<span class="d_keyword">assert</span> (<b>msg</b>.data.asString() == <span class="d_string">"Hello World!"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property @safe SocketType <span class="symbol-target" id="type">&nbsp;</span><a class="symbol-link" href="#type">type</a>();
</h3></div>
<div class="declaration-content"><dl><p>The socket type.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_getsockopt()">zmq_getsockopt()</a></code> with <code>ZMQ_TYPE</code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> sck = Socket(SocketType.xpub);
<span class="d_keyword">assert</span> (sck.<u>type</u> == SocketType.xpub);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property @safe bool <span class="symbol-target" id="more">&nbsp;</span><a class="symbol-link" href="#more">more</a>();
</h3></div>
<div class="declaration-content"><dl><p>Whether there are more message frames to follow.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_getsockopt()">zmq_getsockopt()</a></code> with <code>ZMQ_RCVMORE</code>.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property @safe int <span class="symbol-target" id="sendHWM">&nbsp;</span><a class="symbol-link" href="#sendHWM">sendHWM</a>();
<br>@property @safe void <span class="symbol-target" id="sendHWM">&nbsp;</span><a class="symbol-link" href="#sendHWM">sendHWM</a>(int <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="receiveHWM">&nbsp;</span><a class="symbol-link" href="#receiveHWM">receiveHWM</a>();
<br>@property @safe void <span class="symbol-target" id="receiveHWM">&nbsp;</span><a class="symbol-link" href="#receiveHWM">receiveHWM</a>(int <i>value</i>);
<br>@property @safe ulong <span class="symbol-target" id="threadAffinity">&nbsp;</span><a class="symbol-link" href="#threadAffinity">threadAffinity</a>();
<br>@property @safe void <span class="symbol-target" id="threadAffinity">&nbsp;</span><a class="symbol-link" href="#threadAffinity">threadAffinity</a>(ulong <i>value</i>);
<br>@property @safe ubyte[] <span class="symbol-target" id="identity">&nbsp;</span><a class="symbol-link" href="#identity">identity</a>();
<br>@safe ubyte[] <span class="symbol-target" id="getIdentity">&nbsp;</span><a class="symbol-link" href="#getIdentity">getIdentity</a>(ubyte[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="identity">&nbsp;</span><a class="symbol-link" href="#identity">identity</a>(const ubyte[] <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="identity">&nbsp;</span><a class="symbol-link" href="#identity">identity</a>(const char[] <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="rate">&nbsp;</span><a class="symbol-link" href="#rate">rate</a>();
<br>@property @safe void <span class="symbol-target" id="rate">&nbsp;</span><a class="symbol-link" href="#rate">rate</a>(int <i>value</i>);
<br>@property @safe Duration <span class="symbol-target" id="recoveryInterval">&nbsp;</span><a class="symbol-link" href="#recoveryInterval">recoveryInterval</a>();
<br>@property @safe void <span class="symbol-target" id="recoveryInterval">&nbsp;</span><a class="symbol-link" href="#recoveryInterval">recoveryInterval</a>(Duration <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="sendBufferSize">&nbsp;</span><a class="symbol-link" href="#sendBufferSize">sendBufferSize</a>();
<br>@property @safe void <span class="symbol-target" id="sendBufferSize">&nbsp;</span><a class="symbol-link" href="#sendBufferSize">sendBufferSize</a>(int <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="receiveBufferSize">&nbsp;</span><a class="symbol-link" href="#receiveBufferSize">receiveBufferSize</a>();
<br>@property @safe void <span class="symbol-target" id="receiveBufferSize">&nbsp;</span><a class="symbol-link" href="#receiveBufferSize">receiveBufferSize</a>(int <i>value</i>);
<br>@property @safe Duration <span class="symbol-target" id="linger">&nbsp;</span><a class="symbol-link" href="#linger">linger</a>();
<br>@property @safe void <span class="symbol-target" id="linger">&nbsp;</span><a class="symbol-link" href="#linger">linger</a>(Duration <i>value</i>);
<br>@property @safe Duration <span class="symbol-target" id="reconnectionInterval">&nbsp;</span><a class="symbol-link" href="#reconnectionInterval">reconnectionInterval</a>();
<br>@property @safe void <span class="symbol-target" id="reconnectionInterval">&nbsp;</span><a class="symbol-link" href="#reconnectionInterval">reconnectionInterval</a>(Duration <i>value</i>);
<br>@property @safe Duration <span class="symbol-target" id="maxReconnectionInterval">&nbsp;</span><a class="symbol-link" href="#maxReconnectionInterval">maxReconnectionInterval</a>();
<br>@property @safe void <span class="symbol-target" id="maxReconnectionInterval">&nbsp;</span><a class="symbol-link" href="#maxReconnectionInterval">maxReconnectionInterval</a>(Duration <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="backlog">&nbsp;</span><a class="symbol-link" href="#backlog">backlog</a>();
<br>@property @safe void <span class="symbol-target" id="backlog">&nbsp;</span><a class="symbol-link" href="#backlog">backlog</a>(int <i>value</i>);
<br>@property @safe long <span class="symbol-target" id="maxMsgSize">&nbsp;</span><a class="symbol-link" href="#maxMsgSize">maxMsgSize</a>();
<br>@property @safe void <span class="symbol-target" id="maxMsgSize">&nbsp;</span><a class="symbol-link" href="#maxMsgSize">maxMsgSize</a>(long <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="multicastHops">&nbsp;</span><a class="symbol-link" href="#multicastHops">multicastHops</a>();
<br>@property @safe void <span class="symbol-target" id="multicastHops">&nbsp;</span><a class="symbol-link" href="#multicastHops">multicastHops</a>(int <i>value</i>);
<br>@property @safe Duration <span class="symbol-target" id="receiveTimeout">&nbsp;</span><a class="symbol-link" href="#receiveTimeout">receiveTimeout</a>();
<br>@property @safe void <span class="symbol-target" id="receiveTimeout">&nbsp;</span><a class="symbol-link" href="#receiveTimeout">receiveTimeout</a>(Duration <i>value</i>);
<br>@property @safe Duration <span class="symbol-target" id="sendTimeout">&nbsp;</span><a class="symbol-link" href="#sendTimeout">sendTimeout</a>();
<br>@property @safe void <span class="symbol-target" id="sendTimeout">&nbsp;</span><a class="symbol-link" href="#sendTimeout">sendTimeout</a>(Duration <i>value</i>);
<br>@property @safe bool <span class="symbol-target" id="ipv6">&nbsp;</span><a class="symbol-link" href="#ipv6">ipv6</a>();
<br>@property @safe void <span class="symbol-target" id="ipv6">&nbsp;</span><a class="symbol-link" href="#ipv6">ipv6</a>(bool <i>value</i>);
<br>deprecated @property @safe bool <span class="symbol-target" id="ipv4Only">&nbsp;</span><a class="symbol-link" href="#ipv4Only">ipv4Only</a>();
<br>deprecated @property @safe void <span class="symbol-target" id="ipv4Only">&nbsp;</span><a class="symbol-link" href="#ipv4Only">ipv4Only</a>(bool <i>value</i>);
<br>@property @safe bool <span class="symbol-target" id="immediate">&nbsp;</span><a class="symbol-link" href="#immediate">immediate</a>();
<br>@property @safe void <span class="symbol-target" id="immediate">&nbsp;</span><a class="symbol-link" href="#immediate">immediate</a>(bool <i>value</i>);
<br>deprecated @property @safe bool <span class="symbol-target" id="delayAttachOnConnect">&nbsp;</span><a class="symbol-link" href="#delayAttachOnConnect">delayAttachOnConnect</a>();
<br>deprecated @property @safe void <span class="symbol-target" id="delayAttachOnConnect">&nbsp;</span><a class="symbol-link" href="#delayAttachOnConnect">delayAttachOnConnect</a>(bool <i>value</i>);
<br>@property @safe FD <span class="symbol-target" id="fd">&nbsp;</span><a class="symbol-link" href="#fd">fd</a>();
<br>@property @safe PollFlags <span class="symbol-target" id="events">&nbsp;</span><a class="symbol-link" href="#events">events</a>();
<br>@property @trusted char[] <span class="symbol-target" id="lastEndpoint">&nbsp;</span><a class="symbol-link" href="#lastEndpoint">lastEndpoint</a>();
<br>@property @safe void <span class="symbol-target" id="routerMandatory">&nbsp;</span><a class="symbol-link" href="#routerMandatory">routerMandatory</a>(bool <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="probeRouter">&nbsp;</span><a class="symbol-link" href="#probeRouter">probeRouter</a>(bool <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="xpubVerbose">&nbsp;</span><a class="symbol-link" href="#xpubVerbose">xpubVerbose</a>(bool <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="reqCorrelate">&nbsp;</span><a class="symbol-link" href="#reqCorrelate">reqCorrelate</a>(bool <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="reqRelaxed">&nbsp;</span><a class="symbol-link" href="#reqRelaxed">reqRelaxed</a>(bool <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="tcpKeepalive">&nbsp;</span><a class="symbol-link" href="#tcpKeepalive">tcpKeepalive</a>();
<br>@property @safe void <span class="symbol-target" id="tcpKeepalive">&nbsp;</span><a class="symbol-link" href="#tcpKeepalive">tcpKeepalive</a>(int <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="tcpKeepaliveIdle">&nbsp;</span><a class="symbol-link" href="#tcpKeepaliveIdle">tcpKeepaliveIdle</a>();
<br>@property @safe void <span class="symbol-target" id="tcpKeepaliveIdle">&nbsp;</span><a class="symbol-link" href="#tcpKeepaliveIdle">tcpKeepaliveIdle</a>(int <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="tcpKeepaliveCnt">&nbsp;</span><a class="symbol-link" href="#tcpKeepaliveCnt">tcpKeepaliveCnt</a>();
<br>@property @safe void <span class="symbol-target" id="tcpKeepaliveCnt">&nbsp;</span><a class="symbol-link" href="#tcpKeepaliveCnt">tcpKeepaliveCnt</a>(int <i>value</i>);
<br>@property @safe int <span class="symbol-target" id="tcpKeepaliveIntvl">&nbsp;</span><a class="symbol-link" href="#tcpKeepaliveIntvl">tcpKeepaliveIntvl</a>();
<br>@property @safe void <span class="symbol-target" id="tcpKeepaliveIntvl">&nbsp;</span><a class="symbol-link" href="#tcpKeepaliveIntvl">tcpKeepaliveIntvl</a>(int <i>value</i>);
<br>@property @safe Security <span class="symbol-target" id="mechanism">&nbsp;</span><a class="symbol-link" href="#mechanism">mechanism</a>();
<br>@property @safe bool <span class="symbol-target" id="plainServer">&nbsp;</span><a class="symbol-link" href="#plainServer">plainServer</a>();
<br>@property @safe void <span class="symbol-target" id="plainServer">&nbsp;</span><a class="symbol-link" href="#plainServer">plainServer</a>(bool <i>value</i>);
<br>@safe char[] <span class="symbol-target" id="getPlainUsername">&nbsp;</span><a class="symbol-link" href="#getPlainUsername">getPlainUsername</a>(char[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="plainUsername">&nbsp;</span><a class="symbol-link" href="#plainUsername">plainUsername</a>(const(char)[] <i>value</i>);
<br>@safe char[] <span class="symbol-target" id="getPlainPassword">&nbsp;</span><a class="symbol-link" href="#getPlainPassword">getPlainPassword</a>(char[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="plainPassword">&nbsp;</span><a class="symbol-link" href="#plainPassword">plainPassword</a>(const(char)[] <i>value</i>);
<br>@property @safe bool <span class="symbol-target" id="curveServer">&nbsp;</span><a class="symbol-link" href="#curveServer">curveServer</a>();
<br>@property @safe void <span class="symbol-target" id="curveServer">&nbsp;</span><a class="symbol-link" href="#curveServer">curveServer</a>(bool <i>value</i>);
<br>@property @safe ubyte[] <span class="symbol-target" id="curvePublicKey">&nbsp;</span><a class="symbol-link" href="#curvePublicKey">curvePublicKey</a>();
<br>@safe ubyte[] <span class="symbol-target" id="getCurvePublicKey">&nbsp;</span><a class="symbol-link" href="#getCurvePublicKey">getCurvePublicKey</a>(ubyte[] <i>dest</i>);
<br>@property @safe char[] <span class="symbol-target" id="curvePublicKeyZ85">&nbsp;</span><a class="symbol-link" href="#curvePublicKeyZ85">curvePublicKeyZ85</a>();
<br>@safe char[] <span class="symbol-target" id="getCurvePublicKeyZ85">&nbsp;</span><a class="symbol-link" href="#getCurvePublicKeyZ85">getCurvePublicKeyZ85</a>(char[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="curvePublicKey">&nbsp;</span><a class="symbol-link" href="#curvePublicKey">curvePublicKey</a>(const(ubyte)[] <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="curvePublicKeyZ85">&nbsp;</span><a class="symbol-link" href="#curvePublicKeyZ85">curvePublicKeyZ85</a>(const(char)[] <i>value</i>);
<br>@property @safe ubyte[] <span class="symbol-target" id="curveSecretKey">&nbsp;</span><a class="symbol-link" href="#curveSecretKey">curveSecretKey</a>();
<br>@safe ubyte[] <span class="symbol-target" id="getCurveSecretKey">&nbsp;</span><a class="symbol-link" href="#getCurveSecretKey">getCurveSecretKey</a>(ubyte[] <i>dest</i>);
<br>@property @safe char[] <span class="symbol-target" id="curveSecretKeyZ85">&nbsp;</span><a class="symbol-link" href="#curveSecretKeyZ85">curveSecretKeyZ85</a>();
<br>@safe char[] <span class="symbol-target" id="getCurveSecretKeyZ85">&nbsp;</span><a class="symbol-link" href="#getCurveSecretKeyZ85">getCurveSecretKeyZ85</a>(char[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="curveSecretKey">&nbsp;</span><a class="symbol-link" href="#curveSecretKey">curveSecretKey</a>(const(ubyte)[] <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="curveSecretKeyZ85">&nbsp;</span><a class="symbol-link" href="#curveSecretKeyZ85">curveSecretKeyZ85</a>(const(char)[] <i>value</i>);
<br>@property @safe ubyte[] <span class="symbol-target" id="curveServerKey">&nbsp;</span><a class="symbol-link" href="#curveServerKey">curveServerKey</a>();
<br>@safe ubyte[] <span class="symbol-target" id="getCurveServerKey">&nbsp;</span><a class="symbol-link" href="#getCurveServerKey">getCurveServerKey</a>(ubyte[] <i>dest</i>);
<br>@property @safe char[] <span class="symbol-target" id="curveServerKeyZ85">&nbsp;</span><a class="symbol-link" href="#curveServerKeyZ85">curveServerKeyZ85</a>();
<br>@safe char[] <span class="symbol-target" id="getCurveServerKeyZ85">&nbsp;</span><a class="symbol-link" href="#getCurveServerKeyZ85">getCurveServerKeyZ85</a>(char[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="curveServerKey">&nbsp;</span><a class="symbol-link" href="#curveServerKey">curveServerKey</a>(const(ubyte)[] <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="curveServerKeyZ85">&nbsp;</span><a class="symbol-link" href="#curveServerKeyZ85">curveServerKeyZ85</a>(const(char)[] <i>value</i>);
<br>@property @safe char[] <span class="symbol-target" id="zapDomain">&nbsp;</span><a class="symbol-link" href="#zapDomain">zapDomain</a>();
<br>@safe char[] <span class="symbol-target" id="getZapDomain">&nbsp;</span><a class="symbol-link" href="#getZapDomain">getZapDomain</a>(char[] <i>dest</i>);
<br>@property @safe void <span class="symbol-target" id="zapDomain">&nbsp;</span><a class="symbol-link" href="#zapDomain">zapDomain</a>(const char[] <i>value</i>);
<br>@property @safe void <span class="symbol-target" id="conflate">&nbsp;</span><a class="symbol-link" href="#conflate">conflate</a>(bool <i>value</i>);
</h3></div>
<div class="declaration-content"><dl><p>Misc. socket options.
</p>
<p>Each of these has a one-to-one correspondence with an option passed to
    <code><a href="http://api.zeromq.org/4-0:zmq_getsockopt()">zmq_getsockopt()</a></code> and <code><a href="http://api.zeromq.org/4-0:zmq_setsockopt()">zmq_setsockopt()</a></code>. For
    example, <code>identity</code> corresponds to <code>ZMQ_IDENTITY</code>,
    <code>receiveBufferSize</code> corresponds to <code>ZMQ_RCVBUF</code>, etc.

</p>
<dt>Notes:</dt><dd>
    <ul>        <li>For convenience, the setter for the <code>identity</code> property
            accepts strings.  To retrieve a string with the getter, use
            the <code><a href="#asString">asString()</a></code> function.
<pre class="d_code">sck.identity = <span class="d_string">"foobar"</span>;
<span class="d_keyword">assert</span> (sck.identity.asString() == <span class="d_string">"foobar"</span>);
</pre>
            </li>
        <li>The <code>linger</code>, <code>receiveTimeout</code> and <code>sendTimeout</code>
            properties may have the special value <code><a href="http://dlang.org/phobos/core_time.html#.Duration.max">core.time.Duration.max</a></code>,
            which in this context specifies an infinite duration.  This  is
            translated to an option value of -1 in the C API (and it is also
            the default value for all of them).</li>
        <li>Some options have array type, and these allow the user to supply
            a buffer in which to store the value, to avoid a GC allocation.
            The return value is then a slice of this buffer.
            These are not marked as <code>@property</code>, but are prefixed with
            "get" (e.g. <code>getIdentity()</code>).  A user-supplied buffer is
            <i>required</i> for some options, namely <code>getPlainUsername()</code>
            and <code>getPlainPassword()</code>, and these do not have <code>@property</code>
            versions.  <code>getCurveXxxKey()</code> and <code>getCurveXxxKeyZ85()</code>
            require buffers which are at least 32 and 41 bytes long,
            respectively.</li>
        <li>The <code>ZMQ_SUBSCRIBE</code> and <code>ZMQ_UNSUBSCRIBE</code> options are
            treated differently from the others; see <code><a href="#Socket.subscribe">Socket.subscribe()</a></code>
            and <code><a href="#Socket.unsubscribe">Socket.unsubscribe()</a></code></li>
    </ul>

</dd>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.<br>
        <code><a href="http://dlang.org/phobos/std_conv.html#.ConvOverflowException">std.conv.ConvOverflowException</a></code> if a given <code>Duration</code> is
            longer than the number of milliseconds that will fit in an <code>int</code>
            (only applies to properties of <code><a href="http://dlang.org/phobos/core_time.html#.Duration">core.time.Duration</a></code> type).<br>
        <code><a href="http://dlang.org/phobos/core_exception.html#.RangeError">core.exception.RangeError</a></code> if the <code>dest</code> buffers passed to
            <code>getCurveXxxKey()</code> or <code>getCurveXxxKeyZ85()</code> are less than
            32 or 41 bytes long, respectively.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_getsockopt()">zmq_getsockopt()</a></code> and <code><a href="http://api.zeromq.org/4-0:zmq_setsockopt()">zmq_setsockopt()</a></code>.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="subscribe">&nbsp;</span><a class="symbol-link" href="#subscribe">subscribe</a>(const ubyte[] <i>filterPrefix</i>);
<br>@safe void <span class="symbol-target" id="subscribe">&nbsp;</span><a class="symbol-link" href="#subscribe">subscribe</a>(const char[] <i>filterPrefix</i>);
</h3></div>
<div class="declaration-content"><dl><p>Establishes a message filter.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_setsockopt()">zmq_msg_setsockopt()</a></code> with <code>ZMQ_SUBSCRIBE</code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_comment">// Create a subscriber that accepts all messages that start with
</span><span class="d_comment">// the prefixes "foo" or "bar".
</span><span class="d_keyword">auto</span> sck = Socket(SocketType.sub);
sck.<u>subscribe</u>(<span class="d_string">"foo"</span>);
sck.<u>subscribe</u>(<span class="d_string">"bar"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="unsubscribe">&nbsp;</span><a class="symbol-link" href="#unsubscribe">unsubscribe</a>(const ubyte[] <i>filterPrefix</i>);
<br>@safe void <span class="symbol-target" id="unsubscribe">&nbsp;</span><a class="symbol-link" href="#unsubscribe">unsubscribe</a>(const char[] <i>filterPrefix</i>);
</h3></div>
<div class="declaration-content"><dl><p>Removes a message filter.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_setsockopt()">zmq_msg_setsockopt()</a></code> with <code>ZMQ_SUBSCRIBE</code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_comment">// Subscribe to messages that start with "foo" or "bar".
</span><span class="d_keyword">auto</span> sck = Socket(SocketType.sub);
sck.subscribe(<span class="d_string">"foo"</span>);
sck.subscribe(<span class="d_string">"bar"</span>);
<span class="d_comment">// ...
</span><span class="d_comment">// From now on, only accept messages that start with "bar"
</span>sck.<u>unsubscribe</u>(<span class="d_string">"foo"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="monitor">&nbsp;</span><a class="symbol-link" href="#monitor">monitor</a>(const char[] <i>endpoint</i>, EventType <i>events</i> = EventType.all);
</h3></div>
<div class="declaration-content"><dl><p>Spawns a PAIR socket that publishes socket state changes (<i>events</i>) over
    the INPROC transport to the given <i>endpoint</i>.
</p>
<p>Which event types should be published may be selected by bitwise-ORing
    together different <code><a href="#EventType">EventType</a></code> flags in the <code>event</code> parameter.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_socket_monitor()">zmq_socket_monitor()</a></code>
</dd>
<dt>See Also</dt><dd><code><a href="#receiveEvent">receiveEvent()</a></code>, which receives and parses event messages.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> sck = Socket(SocketType.pub);
sck.<u>monitor</u>(<span class="d_string">"inproc://zmqd_monitor_unittest"</span>,
            EventType.accepted | EventType.closed);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>inout pure nothrow @property @safe inout(void)* <span class="symbol-target" id="handle">&nbsp;</span><a class="symbol-link" href="#handle">handle</a>();
</h3></div>
<div class="declaration-content"><dl><p>The <code>void*</code> pointer used by the underlying C API to refer to the socket.
</p>
<p>If the object has not been initialized, this function returns <code><span class="d_keyword">null</span></code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe bool <span class="symbol-target" id="initialized">&nbsp;</span><a class="symbol-link" href="#initialized">initialized</a>();
</h3></div>
<div class="declaration-content"><dl><p>Whether this <code><a href="#Socket">Socket</a></code> object has been initialized, i.e. whether it
    refers to a valid &#x2205;MQ socket.</p>
<dt>Examples</dt><dd><pre class="d_code">
Socket sck;
<span class="d_keyword">assert</span> (!sck.<u>initialized</u>);
sck = Socket(SocketType.sub);
<span class="d_keyword">assert</span> (sck.<u>initialized</u>);
sck.close();
<span class="d_keyword">assert</span> (!sck.<u>initialized</u>);
</pre>
</dd></dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>alias <span class="symbol-target" id="FD">&nbsp;</span><a class="symbol-link" href="#FD">FD</a> = int;
</h3></div>
<div class="declaration-content"><dl><p>The native socket file descriptor type.
</p>
<p>This is an alias for <code>SOCKET</code> on Windows and <code>int</code> on POSIX systems.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="proxy">&nbsp;</span><a class="symbol-link" href="#proxy">proxy</a>(ref Socket <i>frontend</i>, ref Socket <i>backend</i>);
<br>@safe void <span class="symbol-target" id="proxy">&nbsp;</span><a class="symbol-link" href="#proxy">proxy</a>(ref Socket <i>frontend</i>, ref Socket <i>backend</i>, ref Socket <i>capture</i>);
</h3></div>
<div class="declaration-content"><dl><p>Starts the built-in &#x2205;MQ proxy.
</p>
<p>This function never returns normally, but it may throw an exception.  This could
happen if the context associated with either of the specified sockets is
manually destroyed in a different thread.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_proxy()">zmq_proxy()</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@trusted uint <span class="symbol-target" id="poll">&nbsp;</span><a class="symbol-link" href="#poll">poll</a>(PollItem[] <i>items</i>, Duration <i>timeout</i> = Duration.max);
</h3></div>
<div class="declaration-content"><dl><p>Input/output multiplexing.
</p>
<p>The <code><i>timeout</i></code> parameter may have the special value
<code><a href="http://dlang.org/phobos/core_time.html#.Duration.max">core.time.Duration.max</a></code>, which in this context specifies an infinite
duration.  This is translated to an argument value of -1 in the C API.

</p>
<dt>Returns</dt><dd>The number of <code><a href="#PollItem">PollItem</a></code> structures with events signalled in
    <code><a href="#PollItem.returnedEvents">PollItem.returnedEvents</a></code>, or 0 if no events have been signalled.
</dd>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_poll()">zmq_poll()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> socket1 = zmqd.Socket(zmqd.SocketType.pull);
socket1.bind(<span class="d_string">"inproc://zmqd_poll_example"</span>);

<span class="d_keyword">import</span> std.socket;
<span class="d_keyword">auto</span> socket2 = <span class="d_keyword">new</span> std.socket.Socket(
    AddressFamily.INET,
    std.socket.SocketType.DGRAM);
socket2.bind(<span class="d_keyword">new</span> InternetAddress(InternetAddress.ADDR_ANY, 5678));

<span class="d_keyword">auto</span> socket3 = zmqd.Socket(zmqd.SocketType.push);
socket3.connect(<span class="d_string">"inproc://zmqd_poll_example"</span>);
socket3.send(<span class="d_string">"test"</span>);

<span class="d_keyword">import</span> core.thread: Thread;
Thread.sleep(10.msecs);

<span class="d_keyword">auto</span> <b>items</b> = [
    PollItem(socket1, PollFlags.pollIn),
    PollItem(socket2, PollFlags.pollIn | PollFlags.pollOut),
    PollItem(socket3, PollFlags.pollIn),
];

<span class="d_keyword">const</span> n = <u>poll</u>(<b>items</b>, 100.msecs);
<span class="d_keyword">assert</span> (n == 2);
<span class="d_keyword">assert</span> (<b>items</b>[0].returnedEvents == PollFlags.pollIn);
<span class="d_keyword">assert</span> (<b>items</b>[1].returnedEvents == PollFlags.pollOut);
<span class="d_keyword">assert</span> (<b>items</b>[2].returnedEvents == 0);
socket2.close();
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="PollFlags">&nbsp;</span><a class="symbol-link" href="#PollFlags">PollFlags</a>: int;
</h3></div>
<div class="declaration-content"><dl><p><code><a href="#poll">poll()</a></code> event flags.
</p>
<p>These are described in the <code><a href="http://api.zeromq.org/4-0:zmq_poll()">zmq_poll()</a></code> manual.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="pollIn">&nbsp;</span><a class="symbol-link" href="#pollIn">pollIn</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_POLLIN</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="pollOut">&nbsp;</span><a class="symbol-link" href="#pollOut">pollOut</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_POLLOUT</code></p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="pollErr">&nbsp;</span><a class="symbol-link" href="#pollErr">pollErr</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_POLLERR</code></p>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="PollItem">&nbsp;</span><a class="symbol-link" href="#PollItem">PollItem</a>;
</h3></div>
<div class="declaration-content"><dl><p>A structure that specifies a socket to be monitored by <code><a href="#poll">poll()</a></code> as well
as the events to poll for, and, when <code><a href="#poll">poll()</a></code> returns, the events that
occurred.
</p>
<dt>Warning:</dt><dd>
    <code><span class="symbol-target" id="PollItem">&nbsp;</span><a class="symbol-link" href="#PollItem">PollItem</a></code> objects do not store <code><a href="http://dlang.org/phobos/std_socket.html#.Socket">std.socket.Socket</a></code> references,
    only the corresponding native file descriptors.  This means that the
    references have to be stored elsewhere, or the objects may be garbage
    collected, invalidating the sockets before or while <code><a href="#poll">poll()</a></code> executes.
<pre class="d_code"><span class="d_comment">// Not OK
</span><span class="d_keyword">auto</span> p1 = <u>PollItem</u>(<span class="d_keyword">new</span> std.socket.Socket(<span class="d_comment">/*...*/</span>), PollFlags.pollIn);

<span class="d_comment">// OK
</span><span class="d_keyword">auto</span> s = <span class="d_keyword">new</span> std.socket.Socket(<span class="d_comment">/*...*/</span>);
<span class="d_keyword">auto</span> p2 = <u>PollItem</u>(s, PollFlags.pollIn);
</pre>
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_poll">zmq_pollitem_t</a></code></dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>nothrow @safe this(ref zmqd.Socket <i>socket</i>, PollFlags <i>events</i>);
</h3></div>
<div class="declaration-content"><dl><p>Constructs a <code><a href="#PollItem">PollItem</a></code> for monitoring a &#x2205;MQ <i>socket</i>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@system this(std.<i>socket</i>.Socket <i>socket</i>, PollFlags <i>events</i>);
</h3></div>
<div class="declaration-content"><dl><p>Constructs a <code><a href="#PollItem">PollItem</a></code> for monitoring a standard <i>socket</i> referenced
    by a <code><a href="http://dlang.org/phobos/std_<i>socket</i>.html#.Socket">std.<i>socket</i>.Socket</a></code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>pure nothrow @safe this(FD <i>fd</i>, PollFlags <i>events</i>);
</h3></div>
<div class="declaration-content"><dl><p>Constructs a <code><a href="#PollItem">PollItem</a></code> for monitoring a standard socket referenced
    by a native file descriptor.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>pure nothrow @property @safe void <span class="symbol-target" id="requestedEvents">&nbsp;</span><a class="symbol-link" href="#requestedEvents">requestedEvents</a>(PollFlags <i>events</i>);
<br>const pure nothrow @property @safe PollFlags <span class="symbol-target" id="requestedEvents">&nbsp;</span><a class="symbol-link" href="#requestedEvents">requestedEvents</a>();
</h3></div>
<div class="declaration-content"><dl><p>Requested <i>events</i>.
</p>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_poll">zmq_pollitem_t.<i>events</i></a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe PollFlags <span class="symbol-target" id="returnedEvents">&nbsp;</span><a class="symbol-link" href="#returnedEvents">returnedEvents</a>();
</h3></div>
<div class="declaration-content"><dl><p>Returned events.
</p>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_poll">zmq_pollitem_t.revents</a></code></dd>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Frame">&nbsp;</span><a class="symbol-link" href="#Frame">Frame</a>;
</h3></div>
<div class="declaration-content"><dl><p>An object that encapsulates a &#x2205;MQ message frame.
</p>
<p>This <code>struct</code> is a wrapper around a <code>zmq_msg_t</code> object.
A default-initialized <code><span class="symbol-target" id="Frame">&nbsp;</span><a class="symbol-link" href="#Frame">Frame</a></code> is not a valid &#x2205;MQ message frame; it
should always be explicitly initialized upon construction using
<code><a href="#Frame.opCall">Frame.opCall()</a></code>.  Alternatively, it may be initialized later with
<code><a href="#Frame.rebuild">Frame.rebuild()</a></code>.
<pre class="d_code"><u>Frame</u> msg1;                 <span class="d_comment">// Invalid frame
</span><span class="d_keyword">auto</span> msg2 = <u>Frame</u>();        <span class="d_comment">// Empty frame
</span><span class="d_keyword">auto</span> msg3 = <u>Frame</u>(1024);    <span class="d_comment">// 1K frame
</span>msg1.rebuild(2048);         <span class="d_comment">// msg1 now has size 2K
</span>msg2.rebuild(2048);         <span class="d_comment">// ...and so does msg2
</span></pre>
When a <code><span class="symbol-target" id="Frame">&nbsp;</span><a class="symbol-link" href="#Frame">Frame</a></code> goes out of scope, <code><a href="http://api.zeromq.org/4-0:zmq_msg_close()">zmq_msg_close()</a></code> is
called on the underlying <code>zmq_msg_t</code>.
<br><br>

A <code><span class="symbol-target" id="Frame">&nbsp;</span><a class="symbol-link" href="#Frame">Frame</a></code> cannot be copied by normal assignment; use <code><a href="#Frame.copy">Frame.copy()</a></code>
for this.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>static @safe Frame <span class="symbol-target" id="opCall">&nbsp;</span><a class="symbol-link" href="#opCall">opCall</a>();
</h3></div>
<div class="declaration-content"><dl><p>Initializes an empty &#x2205;MQ message frame.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_init()">zmq_msg_init()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> msg = Frame();
<span class="d_keyword">assert</span>(msg.size == 0);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>static @safe Frame <span class="symbol-target" id="opCall">&nbsp;</span><a class="symbol-link" href="#opCall">opCall</a>(size_t <i>size</i>);
</h3></div>
<div class="declaration-content"><dl><p>
    Initializes a &#x2205;MQ message frame of a specified <i>size</i>.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_init_size()">zmq_msg_init_size()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> msg = Frame(123);
<span class="d_keyword">assert</span>(msg.<b>size</b> == 123);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>static @safe Frame <span class="symbol-target" id="opCall">&nbsp;</span><a class="symbol-link" href="#opCall">opCall</a>(ubyte[] <i>data</i>);
</h3></div>
<div class="declaration-content"><dl><p>
    Initializes a &#x2205;MQ message frame from a supplied buffer.
</p>
<dt>Warning:</dt><dd>
Some care must be taken when using this function, as &#x2205;MQ expects
        to take full ownership of the supplied buffer.  Client code should
        therefore avoid retaining any references to it, including slices that
        contain, overlap with or are contained in <code><i>data</i></code>.
        &#x2205;MQ makes no guarantee that the buffer is not modified,
        and it does not specify when the buffer is released.
<br><br>

        An additional complication is caused by the fact that most arrays in D
        are owned by the garbage collector.  This is solved by adding the array
        pointer as a new garbage collector root before passing it to
        <code><a href="http://api.zeromq.org/4-0:zmq_msg_init_data()">zmq_msg_init_data()</a></code>, thus preventing the GC from collecting
        it.  The root is then removed again in the deallocator callback
        function which is called by &#x2205;MQ when it no longer requires
        the buffer, thus allowing the GC to collect it.
</dd>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_init_data()">zmq_msg_init_data()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> buf = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[123];
<span class="d_keyword">auto</span> msg = Frame(buf);
<span class="d_keyword">assert</span>(msg.size == buf.length);
<span class="d_keyword">assert</span>(msg.<b>data</b>.ptr == buf.ptr);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="rebuild">&nbsp;</span><a class="symbol-link" href="#rebuild">rebuild</a>();
</h3></div>
<div class="declaration-content"><dl><p>Reinitializes the Frame object as an empty message.
</p>
<p>This function will first call <code><a href="#Frame.close">Frame.close()</a></code> to release the
    resources associated with the message frame, and then it will
    initialize it anew, exactly as if it were constructed  with
    <code><a href="#Frame.opCall">Frame()</a></code>.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_close()">zmq_msg_close()</a></code> followed by <code><a href="http://api.zeromq.org/4-0:zmq_msg_init()">zmq_msg_init()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> msg = Frame(256);
<span class="d_keyword">assert</span> (msg.size == 256);
msg.<u>rebuild</u>();
<span class="d_keyword">assert</span> (msg.size == 0);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="rebuild">&nbsp;</span><a class="symbol-link" href="#rebuild">rebuild</a>(size_t <i>size</i>);
</h3></div>
<div class="declaration-content"><dl><p>Reinitializes the Frame object to a specified <i>size</i>.
</p>
<p>This function will first call <code><a href="#Frame.close">Frame.close()</a></code> to release the
    resources associated with the message frame, and then it will
    initialize it anew, exactly as if it were constructed  with
    <code><a href="#Frame.opCall_size">Frame(<i>size</i>)</a></code>.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_close()">zmq_msg_close()</a></code> followed by <code><a href="http://api.zeromq.org/4-0:zmq_msg_init_size()">zmq_msg_init_size()</a></code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> msg = Frame(256);
<span class="d_keyword">assert</span> (msg.<b>size</b> == 256);
msg.<u>rebuild</u>(1024);
<span class="d_keyword">assert</span> (msg.<b>size</b> == 1024);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="rebuild">&nbsp;</span><a class="symbol-link" href="#rebuild">rebuild</a>(ubyte[] <i>data</i>);
</h3></div>
<div class="declaration-content"><dl><p>Reinitializes the Frame object from a supplied buffer.
</p>
<p>This function will first call <code><a href="#Frame.close">Frame.close()</a></code> to release the
    resources associated with the message frame, and then it will
    initialize it anew, exactly as if it were constructed  with
    <code><a href="#Frame.opCall_data">Frame(<i>data</i>)</a></code>.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_close()">zmq_msg_close()</a></code> followed by <code><a href="http://api.zeromq.org/4-0:zmq_msg_init_data()">zmq_msg_init_data()</a></code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> msg = Frame(256);
<span class="d_keyword">assert</span> (msg.size == 256);
<span class="d_keyword">auto</span> buf = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[123];
msg.<u>rebuild</u>(buf);
<span class="d_keyword">assert</span>(msg.size == buf.length);
<span class="d_keyword">assert</span>(msg.<b>data</b>.ptr == buf.ptr);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="close">&nbsp;</span><a class="symbol-link" href="#close">close</a>();
</h3></div>
<div class="declaration-content"><dl><p>Releases the &#x2205;MQ message frame.
</p>
<p>Note that the frame will be automatically released when the <code>Frame</code>
    object is destroyed, so it is often not necessary to call this method
    manually.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_close()">zmq_msg_close()</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe Frame <span class="symbol-target" id="copy">&nbsp;</span><a class="symbol-link" href="#copy">copy</a>();
<br>@safe void <span class="symbol-target" id="copyTo">&nbsp;</span><a class="symbol-link" href="#copyTo">copyTo</a>(ref Frame <i>dest</i>);
</h3></div>
<div class="declaration-content"><dl><p>Copies frame content to another message frame.
</p>
<p><code><span class="symbol-target" id="copy">&nbsp;</span><a class="symbol-link" href="#copy">copy</a>()</code> returns a new <code>Frame</code> object, while <code>copyTo(dest)</code>
    copies the contents of this <code>Frame</code> into <code>dest</code>.  <code>dest</code> must
    be a valid (i.e. initialized) <code>Frame</code>.

</p>
<dt>Warning:</dt><dd>
These functions may not do what you think they do.  Please refer
        to <a href="http://api.zeromq.org/4-0:zmq_msg_copy()">the &#x2205;MQ manual</a> for details.
</dd>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_copy()">zmq_msg_copy()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">import</span> std.string: representation;
<span class="d_keyword">auto</span> msg1 = Frame(3);
msg1.data[] = <span class="d_string">"foo"</span>.representation;
<span class="d_keyword">auto</span> msg2 = msg1.copy();
<span class="d_keyword">assert</span> (msg2.data.asString() == <span class="d_string">"foo"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe Frame <span class="symbol-target" id="move">&nbsp;</span><a class="symbol-link" href="#move">move</a>();
<br>@safe void <span class="symbol-target" id="moveTo">&nbsp;</span><a class="symbol-link" href="#moveTo">moveTo</a>(ref Frame <i>dest</i>);
</h3></div>
<div class="declaration-content"><dl><p>Moves frame content to another message frame.
</p>
<p><code><span class="symbol-target" id="move">&nbsp;</span><a class="symbol-link" href="#move">move</a>()</code> returns a new <code>Frame</code> object, while <code>moveTo(dest)</code>
    moves the contents of this <code>Frame</code> to <code>dest</code>.  <code>dest</code> must
    be a valid (i.e. initialized) <code>Frame</code>.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_move()">zmq_msg_move()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">import</span> std.string: representation;
<span class="d_keyword">auto</span> msg1 = Frame(3);
msg1.data[] = <span class="d_string">"foo"</span>.representation;
<span class="d_keyword">auto</span> msg2 = msg1.move();
<span class="d_keyword">assert</span> (msg1.size == 0);
<span class="d_keyword">assert</span> (msg2.data.asString() == <span class="d_string">"foo"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>nothrow @property @safe size_t <span class="symbol-target" id="size">&nbsp;</span><a class="symbol-link" href="#size">size</a>();
</h3></div>
<div class="declaration-content"><dl><p>The message frame content <span class="symbol-target" id="size">&nbsp;</span><a class="symbol-link" href="#size">size</a> in bytes.
</p>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_size()">zmq_msg_size()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> msg = Frame(123);
<span class="d_keyword">assert</span>(msg.<u>size</u> == 123);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>nothrow @property @trusted ubyte[] <span class="symbol-target" id="data">&nbsp;</span><a class="symbol-link" href="#data">data</a>();
</h3></div>
<div class="declaration-content"><dl><p>Retrieves the message frame content.
</p>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_data()">zmq_msg_data()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">import</span> std.string: representation;
<span class="d_keyword">auto</span> msg = Frame(3);
<span class="d_keyword">assert</span>(msg.<u>data</u>.length == 3);
msg.<u>data</u>[] = <span class="d_string">"foo"</span>.representation; <span class="d_comment">// Slice operator -&gt; array copy.
</span><span class="d_keyword">assert</span>(msg.<u>data</u>.asString() == <span class="d_string">"foo"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>nothrow @property @safe bool <span class="symbol-target" id="more">&nbsp;</span><a class="symbol-link" href="#more">more</a>();
</h3></div>
<div class="declaration-content"><dl><p>Whether there are <span class="symbol-target" id="more">&nbsp;</span><a class="symbol-link" href="#more">more</a> message frames to retrieve.
</p>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_msg_more()">zmq_msg_more()</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>inout pure nothrow @property @safe inout(zmq_msg_t)* <span class="symbol-target" id="handle">&nbsp;</span><a class="symbol-link" href="#handle">handle</a>();
</h3></div>
<div class="declaration-content"><dl><p>A pointer to the underlying <code>zmq_msg_t</code>.</p>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>@trusted Context <span class="symbol-target" id="defaultContext">&nbsp;</span><a class="symbol-link" href="#defaultContext">defaultContext</a>();
</h3></div>
<div class="declaration-content"><dl><p>A global context which is used by default by all sockets, unless they are
explicitly constructed with a different context.
</p>
<p>The &#x2205;MQ Guide <a href="http://zguide.zeromq.org/page:all#Getting-the-Context-Right">has the following to say</a> about context creation:
<blockquote>    You should create and use exactly one context in your process.
    [&hellip;] If at runtime a process has two contexts, these are
    like separate &#x2205;MQ instances. If that's explicitly what you
    want, OK, but otherwise remember: <em>Do one <code>zmq_ctx_new()</code>
    at the start of your main line code, and one <code>zmq_ctx_destroy()</code>
    at the end.</em>
</blockquote>
By using <code><span class="symbol-target" id="defaultContext">&nbsp;</span><a class="symbol-link" href="#defaultContext">defaultContext</a>()</code>, this is exactly what you achieve.  The
context is created the first time the function is called, and is
automatically destroyed when the program ends.
<br><br>

This function is thread safe.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>See Also</dt><dd><code><a href="#Context">Context</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Context">&nbsp;</span><a class="symbol-link" href="#Context">Context</a>;
</h3></div>
<div class="declaration-content"><dl><p>An object that encapsulates a &#x2205;MQ context.
</p>
<p>In most programs, it is not necessary to use this type directly,
as <code><a href="#Socket">Socket</a></code> will use a default global context if not explicitly
provided with one.  See <code><a href="#defaultContext">defaultContext()</a></code> for details.
<br><br>

A default-initialized <code><span class="symbol-target" id="Context">&nbsp;</span><a class="symbol-link" href="#Context">Context</a></code> is not a valid &#x2205;MQ context; it
must always be explicitly initialized with <code><a href="#Context.opCall">Context.opCall()</a></code>:
<pre class="d_code"><u>Context</u> ctx;        <span class="d_comment">// Not a valid context yet
</span>ctx = <u>Context</u>();    <span class="d_comment">// ...but now it is.
</span></pre>
<code><span class="symbol-target" id="Context">&nbsp;</span><a class="symbol-link" href="#Context">Context</a></code> objects can be passed around by value, and two copies will
refer to the same context.  The underlying context is managed using
reference counting, so that when the last copy of a <code><span class="symbol-target" id="Context">&nbsp;</span><a class="symbol-link" href="#Context">Context</a></code> goes
out of scope, the context is automatically destroyed.  The reference
counting is performed in a thread safe manner, so that the same context
can be shared between multiple threads.  (&#x2205;MQ guarantees the thread
safety of other context operations.)

</p>
<dt>See Also</dt><dd><code><a href="#defaultContext">defaultContext()</a></code></dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>static @trusted Context <span class="symbol-target" id="opCall">&nbsp;</span><a class="symbol-link" href="#opCall">opCall</a>();
</h3></div>
<div class="declaration-content"><dl><p>Creates a new &#x2205;MQ context.
</p>
<dt>Returns</dt><dd>A <code><a href="#Context">Context</a></code> object that encapsulates the new context.
</dd>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_ctx_new()">zmq_ctx_new()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> ctx = Context();
<span class="d_keyword">assert</span> (ctx.initialized);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe void <span class="symbol-target" id="detach">&nbsp;</span><a class="symbol-link" href="#detach">detach</a>();
</h3></div>
<div class="declaration-content"><dl><p>Detaches from the &#x2205;MQ context.
</p>
<p>If this is the last reference to the context, it will be destroyed with
    <code><a href="http://api.zeromq.org/4-0:zmq_ctx_destroy()">zmq_ctx_destroy()</a></code>.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> ctx = Context();
<span class="d_keyword">assert</span> (ctx.initialized);
ctx.<u>detach</u>();
<span class="d_keyword">assert</span> (!ctx.initialized);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property @safe int <span class="symbol-target" id="ioThreads">&nbsp;</span><a class="symbol-link" href="#ioThreads">ioThreads</a>();
<br>@property @safe void <span class="symbol-target" id="ioThreads">&nbsp;</span><a class="symbol-link" href="#ioThreads">ioThreads</a>(int <i>value</i>);
</h3></div>
<div class="declaration-content"><dl><p>The number of I/O threads.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_ctx_get()">zmq_ctx_get()</a></code> and <code><a href="http://api.zeromq.org/4-0:zmq_ctx_set()">zmq_ctx_set()</a></code> with
        <code>ZMQ_IO_THREADS</code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> ctx = Context();
ctx.<u>ioThreads</u> = 3;
<span class="d_keyword">assert</span> (ctx.<u>ioThreads</u> == 3);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property @safe int <span class="symbol-target" id="maxSockets">&nbsp;</span><a class="symbol-link" href="#maxSockets">maxSockets</a>();
<br>@property @safe void <span class="symbol-target" id="maxSockets">&nbsp;</span><a class="symbol-link" href="#maxSockets">maxSockets</a>(int <i>value</i>);
</h3></div>
<div class="declaration-content"><dl><p>The maximum number of sockets.
</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_ctx_get()">zmq_ctx_get()</a></code> and <code><a href="http://api.zeromq.org/4-0:zmq_ctx_set()">zmq_ctx_set()</a></code> with
        <code>ZMQ_MAX_SOCKETS</code>.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> ctx = Context();
ctx.<u>maxSockets</u> = 512;
<span class="d_keyword">assert</span> (ctx.<u>maxSockets</u> == 512);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>inout pure nothrow @property @trusted inout(void)* <span class="symbol-target" id="handle">&nbsp;</span><a class="symbol-link" href="#handle">handle</a>();
</h3></div>
<div class="declaration-content"><dl><p>The <code>void*</code> pointer used by the underlying C API to refer to the context.
</p>
<p>If the object has not been initialized, this function returns <code><span class="d_keyword">null</span></code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe bool <span class="symbol-target" id="initialized">&nbsp;</span><a class="symbol-link" href="#initialized">initialized</a>();
</h3></div>
<div class="declaration-content"><dl><p>Whether this <code><a href="#Context">Context</a></code> object has been initialized, i.e. whether it
    refers to a valid &#x2205;MQ context.</p>
<dt>Examples</dt><dd><pre class="d_code">
Context ctx;
<span class="d_keyword">assert</span> (!ctx.<u>initialized</u>);
ctx = Context();
<span class="d_keyword">assert</span> (ctx.<u>initialized</u>);
ctx.detach();
<span class="d_keyword">assert</span> (!ctx.<u>initialized</u>);
</pre>
</dd></dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="EventType">&nbsp;</span><a class="symbol-link" href="#EventType">EventType</a>: int;
</h3></div>
<div class="declaration-content"><dl><p>Socket event types.
</p>
<p>These are used together with <code><a href="#Socket.monitor">Socket.monitor()</a></code>, and are described
in the <code><a href="http://api.zeromq.org/4-0:zmq_socket_monitor()">zmq_socket_monitor()</a></code> reference.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="connected">&nbsp;</span><a class="symbol-link" href="#connected">connected</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_CONNECTED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="connectDelayed">&nbsp;</span><a class="symbol-link" href="#connectDelayed">connectDelayed</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_CONNECT_DELAYED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="connectRetried">&nbsp;</span><a class="symbol-link" href="#connectRetried">connectRetried</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_CONNECT_RETRIED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="listening">&nbsp;</span><a class="symbol-link" href="#listening">listening</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_LISTENING</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="bindFailed">&nbsp;</span><a class="symbol-link" href="#bindFailed">bindFailed</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_BIND_FAILED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="accepted">&nbsp;</span><a class="symbol-link" href="#accepted">accepted</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_ACCEPTED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="acceptFailed">&nbsp;</span><a class="symbol-link" href="#acceptFailed">acceptFailed</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_ACCEPT_FAILED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="closed">&nbsp;</span><a class="symbol-link" href="#closed">closed</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_CLOSED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="closeFailed">&nbsp;</span><a class="symbol-link" href="#closeFailed">closeFailed</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_CLOSE_FAILED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="disconnected">&nbsp;</span><a class="symbol-link" href="#disconnected">disconnected</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_DISCONNECTED</code>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="all">&nbsp;</span><a class="symbol-link" href="#all">all</a></h3></div>
<div class="declaration-content"><dl><p>Corresponds to <code>ZMQ_EVENT_ALL</code>.</p>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>@system Event <span class="symbol-target" id="receiveEvent">&nbsp;</span><a class="symbol-link" href="#receiveEvent">receiveEvent</a>(ref Socket <i>socket</i>);
</h3></div>
<div class="declaration-content"><dl><p>Receives a message on the given <i>socket</i> and interprets it as a <i>socket</i>
state change event.
</p>
<p><code><i>socket</i></code> must be a PAIR <i>socket</i> which is connected to an endpoint
created via a <code><a href="#Socket.monitor">Socket.monitor()</a></code> call.  <code><span class="symbol-target" id="receiveEvent">&nbsp;</span><a class="symbol-link" href="#receiveEvent">receiveEvent</a>()</code> receives
one message on the <i>socket</i>, parses its contents according to the
specification in the <code><a href="http://api.zeromq.org/4-0:zmq_socket_monitor()">zmq_socket_monitor()</a></code> reference,
and returns the event information as an <code><a href="#Event">Event</a></code> object.

</p>
<dt>Throws</dt><dd><code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.<br>
    <code><a href="#InvalidEventException">InvalidEventException</a></code> if the received message could not
    be interpreted as an event message.
</dd>
<dt>See Also</dt><dd><code><a href="#Socket.monitor">Socket.monitor()</a></code>, for monitoring <i>socket</i> state changes.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Event">&nbsp;</span><a class="symbol-link" href="#Event">Event</a>;
</h3></div>
<div class="declaration-content"><dl><p>Information about a socket state change.
</p>
<dt>Corresponds to:</dt><dd>
<a href="http://api.zeromq.org/4-0:zmq_socket_monitor"><code>zmq_event_t</code></a>
</dd>
<dt>See Also</dt><dd><code><a href="#receiveEvent">receiveEvent()</a></code></dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe EventType <span class="symbol-target" id="type">&nbsp;</span><a class="symbol-link" href="#type">type</a>();
</h3></div>
<div class="declaration-content"><dl><p>The event <span class="symbol-target" id="type">&nbsp;</span><a class="symbol-link" href="#type">type</a>.
</p>
<dt>Corresponds to:</dt><dd>
<code>zmq_event_t.event</code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe string <span class="symbol-target" id="address">&nbsp;</span><a class="symbol-link" href="#address">address</a>();
</h3></div>
<div class="declaration-content"><dl><p>The peer <span class="symbol-target" id="address">&nbsp;</span><a class="symbol-link" href="#address">address</a>.
</p>
<dt>Corresponds to:</dt><dd>
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe FD <span class="symbol-target" id="fd">&nbsp;</span><a class="symbol-link" href="#fd">fd</a>();
</h3></div>
<div class="declaration-content"><dl><p>The socket file descriptor.
</p>
<p>This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is one of:
    <code>connected</code>, <code>listening</code>, <code>accepted</code>, <code>closed</code> or <code>disonnected</code>.

</p>
<dt>Throws</dt><dd><code>Error</code> if the property is called for a wrong event type.
</dd>
<dt>Corresponds to:</dt><dd>
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe int <span class="symbol-target" id="errno">&nbsp;</span><a class="symbol-link" href="#errno">errno</a>();
</h3></div>
<div class="declaration-content"><dl><p>The <code><span class="symbol-target" id="errno">&nbsp;</span><a class="symbol-link" href="#errno">errno</a></code> code for the error which triggered the event.
</p>
<p>This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is either
    <code>bindFailed</code>, <code>acceptFailed</code> or <code>closeFailed</code>.

</p>
<dt>Throws</dt><dd><code>Error</code> if the property is called for a wrong event type.
</dd>
<dt>Corresponds to:</dt><dd>
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const pure nothrow @property @safe Duration <span class="symbol-target" id="interval">&nbsp;</span><a class="symbol-link" href="#interval">interval</a>();
</h3></div>
<div class="declaration-content"><dl><p>The reconnect <span class="symbol-target" id="interval">&nbsp;</span><a class="symbol-link" href="#interval">interval</a>.
</p>
<p>This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is
    <code>connectRetried</code>.

</p>
<dt>Throws</dt><dd><code>Error</code> if the property is called for a wrong event type.
</dd>
<dt>Corresponds to:</dt><dd>
<code>zmq_event_t.data.connect_retried.<span class="symbol-target" id="interval">&nbsp;</span><a class="symbol-link" href="#interval">interval</a></code></dd>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>@safe char[] <span class="symbol-target" id="z85Encode">&nbsp;</span><a class="symbol-link" href="#z85Encode">z85Encode</a>(ubyte[] <i>data</i>, char[] <i>dest</i>);
<br>@safe char[] <span class="symbol-target" id="z85Encode">&nbsp;</span><a class="symbol-link" href="#z85Encode">z85Encode</a>(ubyte[] <i>data</i>);
</h3></div>
<div class="declaration-content"><dl><p>Encodes a binary key as Z85 printable text.
</p>
<p><code><i>dest</i></code> must be an array whose length is at least <code>5*<i>data</i>.length/4 + 1</code>,
which will be used to store the return value plus a terminating zero byte.
If <code><i>dest</i></code> is omitted, a new array will be created.

</p>
<dt>Returns</dt><dd>An array of size <code>5*<i>data</i>.length/4</code> which contains the Z85-encoded text,
    excluding the terminating zero byte.  This will be a slice of <code><i>dest</i></code> if
    it is provided.
</dd>
<dt>Throws</dt><dd><code><a href="http://dlang.org/phobos/core_exception.html#.RangeError">core.exception.RangeError</a></code> if <code><i>dest</i></code> is given but is too small.<br>
    <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error (i.e., if <i>data</i>.length is not
    a multiple of 4).
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_z85_encode()">zmq_z85_encode()</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe ubyte[] <span class="symbol-target" id="z85Decode">&nbsp;</span><a class="symbol-link" href="#z85Decode">z85Decode</a>(char[] <i>text</i>, ubyte[] <i>dest</i>);
<br>@safe ubyte[] <span class="symbol-target" id="z85Decode">&nbsp;</span><a class="symbol-link" href="#z85Decode">z85Decode</a>(char[] <i>text</i>);
</h3></div>
<div class="declaration-content"><dl><p>Decodes a binary key from Z85 printable <i>text</i>.
</p>
<p><code><i>dest</i></code> must be an array whose length is at least <code>4*data.length/5</code>,
which will be used to store the return value.
If <code><i>dest</i></code> is omitted, a new array will be created.
<br><br>

Note that <code><a href="http://api.zeromq.org/4-0:zmq_z85_decode()">zmq_z85_decode()</a></code> expects a zero-terminated string, so a zero
byte will be appended to <code><i>text</i></code> if it does not contain one already.  However,
this may trigger a (possibly unwanted) GC allocation.  To avoid this, either
make sure that the last character in <code><i>text</i></code> is <code>'\0'</code>, or use
<code><a href="http://dlang.org/phobos/object.html#.assumeSafeAppend">assumeSafeAppend</a></code> on the array before calling this function.

</p>
<dt>Returns</dt><dd>An array of size <code>4*data.length/5</code> which contains the decoded data.
    This will be a slice of <code><i>dest</i></code> if it is provided.
</dd>
<dt>Throws</dt><dd><code><a href="http://dlang.org/phobos/core_exception.html#.RangeError">core.exception.RangeError</a></code> if <code><i>dest</i></code> is given but is too small.<br>
    <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error (i.e., if data.length is not
    a multiple of 5).
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_z85_decode()">zmq_z85_decode()</a></code></dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@safe Tuple!(char[], "publicKey", char[], "secretKey") <span class="symbol-target" id="curveKeyPair">&nbsp;</span><a class="symbol-link" href="#curveKeyPair">curveKeyPair</a>(char[] <i>publicKeyBuf</i> = null, char[] <i>secretKeyBuf</i> = null);
</h3></div>
<div class="declaration-content"><dl><p>Generates a new CURVE key pair.
</p>
<p>To avoid a memory allocation, preallocated buffers may optionally be supplied
for the two keys.  Each of these must have a length of at least 41 bytes, enough
for a 40-character Z85-encoded key plus a terminating zero byte.  If either
buffer is omitted/<code><span class="d_keyword">null</span></code>, a new one will be created.

</p>
<dt>Returns</dt><dd>A tuple that contains the two keys.  Each of these will have a length of
    40 characters, and will be slices of the input buffers if such have been
    provided.
</dd>
<dt>Throws</dt><dd><code><a href="http://dlang.org/phobos/core_exception.html#.RangeError">core.exception.RangeError</a></code> if <code><i>publicKeyBuf</i></code> or <code><i>secretKeyBuf</i></code> are
        not <code><span class="d_keyword">null</span></code> but have a length of less than 41 characters.<br>
    <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</dd>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_curve_keypair()">zmq_curve_keypair()</a></code></dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> server = Socket(SocketType.rep);
<span class="d_keyword">auto</span> serverKeys = <u>curveKeyPair</u>();
server.curveServer = <span class="d_keyword">true</span>;
server.curveSecretKeyZ85 = serverKeys.secretKey;
server.bind(<span class="d_string">"inproc://curveKeyPair_test"</span>);

<span class="d_keyword">auto</span> client = Socket(SocketType.req);
<span class="d_keyword">auto</span> clientKeys = <u>curveKeyPair</u>();
client.curvePublicKeyZ85 = clientKeys.publicKey;
client.curveSecretKeyZ85 = clientKeys.secretKey;
client.curveServerKeyZ85 = serverKeys.publicKey;
client.connect(<span class="d_string">"inproc://curveKeyPair_test"</span>);
client.send(<span class="d_string">"hello"</span>);

<span class="d_keyword">ubyte</span>[5] buf;
<span class="d_keyword">assert</span> (server.receive(buf) == 5);
<span class="d_keyword">assert</span> (buf.asString() == <span class="d_string">"hello"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>pure @safe inout(char)[] <span class="symbol-target" id="asString">&nbsp;</span><a class="symbol-link" href="#asString">asString</a>(inout(ubyte)[] <i>data</i>);
</h3></div>
<div class="declaration-content"><dl><p>Utility function which interprets and validates a byte array as a UTF-8 string.
</p>
<p>Most of &#x2205;MQD's message API deals in <code>ubyte[]</code> arrays, but very often,
the message data contains plain text.  <code><span class="symbol-target" id="asString">&nbsp;</span><a class="symbol-link" href="#asString">asString</a>()</code> allows for easy and
safe interpretation of raw data as characters.  It checks that <code><i>data</i></code> is
a valid UTF-8 encoded string, and returns a <code>char[]</code> array that refers to
the same memory region.

</p>
<dt>Throws</dt><dd><code><a href="http://dlang.org/phobos/std_utf.html#.UTFException">std.utf.UTFException</a></code> if <code><i>data</i></code> is not a valid UTF-8 string.
</dd>
<dt>See Also</dt><dd><code><a href="http://dlang.org/phobos/std_string.html#.representation">std.string.representation</a></code>, which performs the opposite operation.</dd>
<dt>Examples</dt><dd><pre class="d_code">
<span class="d_keyword">auto</span> s1 = Socket(SocketType.pair);
s1.bind(<span class="d_string">"inproc://zmqd_asString_example"</span>);
<span class="d_keyword">auto</span> s2 = Socket(SocketType.pair);
s2.connect(<span class="d_string">"inproc://zmqd_asString_example"</span>);

<span class="d_keyword">auto</span> msg = Frame(12);
msg.<b>data</b>.<u>asString</u>()[] = <span class="d_string">"Hello World!"</span>;
s1.send(msg);

<span class="d_keyword">ubyte</span>[12] buf;
s2.receive(buf);
<span class="d_keyword">assert</span>(buf.<u>asString</u>() == <span class="d_string">"Hello World!"</span>);
</pre>
</dd></dl>
</div>
<hr><div class="row-fluid declaration"><h3>class <span class="symbol-target" id="ZmqException">&nbsp;</span><a class="symbol-link" href="#ZmqException">ZmqException</a>: <u>object.Exception</u>;
</h3></div>
<div class="declaration-content"><dl><p>A class for exceptions thrown when any of the underlying &#x2205;MQ C functions
report an error.
</p>
<p>The exception provides a standard error message obtained with
<code><a href="http://api.zeromq.org/4-0:zmq_strerror()">zmq_strerror()</a></code>, as well as the <code>errno</code> code set by the &#x2205;MQ
function which reported the error.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>immutable int <span class="symbol-target" id="errno">&nbsp;</span><a class="symbol-link" href="#errno">errno</a>;
</h3></div>
<div class="declaration-content"><dl><p>The <code><span class="symbol-target" id="errno">&nbsp;</span><a class="symbol-link" href="#errno">errno</a></code> code that was set by the &#x2205;MQ function that reported
    the error.
</p>
<dt>Corresponds to:</dt><dd>
<code><a href="http://api.zeromq.org/4-0:zmq_errno()">zmq_errno()</a></code></dd>
</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>class <span class="symbol-target" id="InvalidEventException">&nbsp;</span><a class="symbol-link" href="#InvalidEventException">InvalidEventException</a>: <u>object.Exception</u>;
</h3></div>
<div class="declaration-content"><dl><p>Exception thrown by <code><a href="#receiveEvent">receiveEvent()</a></code> on failure to interpret a
received message as an event description.</p>
</dl>
</div>


				</div>
				
				<hr>
				
				<footer class="pull-left">
					<p>Page generated with <a href="https://github.com/JakobOvrum/bootDoc">bootDoc</a>.</p>
				</footer>
				
				<footer class="pull-right">
					<p>Copyright (c) 20132014, Lars T. Kyllingstad. All rights reserved.
</p>
				</footer>
			</div>
		</div>
	</div><!--/.fluid-container-->

	<!-- Bootstrap javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="bootDoc/assets/js/jquery.min.js"></script>
	<script src="bootDoc/assets/js/bootstrap.min.js"></script>
	
	<!-- bootDoc javascript
	================================================== -->
	<script src="bootDoc/bootdoc.js"></script>
	
	</body>
</html>
