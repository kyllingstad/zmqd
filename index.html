<!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <meta name="generator" content="DMD with DDOC theme LTKdoc 0.1">
            <title>zmqd</title>
            <style type="text/css">
                /* Common styles */
                body {
                    font-family: sans-serif;
                    font-size: 100.01%;
                }
                /* For an explanation of the font-family property value, see:
                   http://meyerweb.com/eric/thoughts/2010/02/12/fixed-monospace-sizing/
                   Basically, it ensures monospace fonts are sized according to
                   the same scale as other fonts, without imposing a fixed size.
                */
                code {
                    font-family: "Nothing to see here, move on",monospace,sans-serif;
                    font-size: 95%;
                    font-weight: bold;
                }
                h1 {
                    font-size: 100%;
                    font-weight: bold;
                    padding: 0;
                    margin: 1ex 0;
                }
                p {
                    font-size: 100%;
                    padding: 0;
                    margin: 1ex 0;
                }
                div.ddoc_paragraphs {
                    font-size: 100%;
                    margin: 1ex 0;
                    padding: 0;
                }
                .warning {
                    color: Red;
                }

                /* Section-specific style */
                section.module>h1 {
                    border-bottom: 1px solid Gray;
                    font-size: 150%;
                }
                section.ddoc_section h1 {
                    margin: 1ex 0 0 0;
                }
                section.members>h1 {
                    display: none;
                }
                section.member {
                    border: 1px solid Gray;
                    margin-bottom: 1ex;
                }
                section.member>* {
                    margin-left: 2em;
                    margin-right: 1em;
                }
                section.member>h1 {
                    background-color: LightBlue;
                    border-bottom: 1px solid Gray;
                    font-size: 100%;
                    margin: 0 0 0 0;
                    padding: 0.5ex 0.5em;
                    text-align: left;
                }
                pre.d_code {
                    background-color: LightGrey;
                    padding: 0.5em;
                }
            </style>
        </head>
        <body>
            <section class="module">
                <h1>zmqd</h1>
                <!-- Generated by Ddoc from src/zmqd.d -->
<p class="summary">A thin wrapper around the low-level C API of the <a href="http://zeromq.org">&#x2205;MQ</a>
messaging framework, for the <a href="http://dlang.org">D programming language</a>.
</p>
<div class="ddoc_paragraphs">Most functions in this module have a one-to-one relationship with functions
in the underlying C API.  Some adaptations have been made to make the API
safer, easier and more pleasant to use, namely:
<ul>   <li>       Errors are signalled by means of exceptions rather than return
        codes.  In particular, the <code><a href="#ZmqException">ZmqException</a></code> class provides
        a standard textual message for any error condition, but it also
        provides access to the <code>errno</code> code set by the C function
        that reported the error.</li>
    <li>       Functions are appropriately marked with <code>@safe</code>, <code>pure</code>
        and <code>nothrow</code>, thus easing their use in high-level D code.</li>
    <li>       Memory and resources (i.e. contexts, sockets and messages) are
        automatically managed, thus preventing leaks.</li>
    <li>       Context, socket and message options are implemented as properties.</li>
</ul>
The names of functions and types in &#x2205;MQD are very similar to those in
&#x2205;MQ, but they follow the D naming conventions.  For example,
<code>zmq_msg_send()</code> becomes <code>zmqd.Message.send()</code> and so on.  Thus,
the library should feel both familiar to &#x2205;MQ users and natural to D
users.
<br><br>

Due to the close correspondence with the C API, this documentation has
intentionally been kept sparse. There is really no reason to repeat the
contents of the <a href="http://api.zeromq.org/3-2:_start">&#x2205;MQ reference manual</a> here.
Instead, the documentation for each function contains a "Corresponds to"
section that links to the appropriate page in the &#x2205;MQ reference.  Any
details given in the present documentation mostly concern the D-specific
adaptations that have been made.
<br><br>

Also note that the examples only use the INPROC and IPC transports.  The
reason for this is that the examples double as unittests, and we want to
avoid firewall troubles and other issues that could arise with the use of
network protocols such as TCP, PGM, etc.  Anyway, they are only short
snippets that demonstrate the syntax; for more comprehensive and realistic
examples, please refer to the <a href="http://zguide.zeromq.org/page:all">&#x2205;MQ Guide</a>.

</div>
<section class="ddoc_section"><h1>Version:</h1><div class="ddoc_paragraphs"> 0.1 (&#x2205;MQ 3.2 compatible)
</div></section>
<section class="ddoc_section"><h1>Authors:</h1><div class="ddoc_paragraphs"> <a href="http://github.com/kyllingstad">Lars T. Kyllingstad</a>
</div></section>
<section class="ddoc_section"><h1>Licence:</h1><div class="ddoc_paragraphs"> &#x2205;MQD is released under a BSD licence (see LICENCE.txt for details).<br>
    Please refer to the <a href="http://zeromq.org/area:licensing">&#x2205;MQ site</a>
    for details about &#x2205;MQ licensing.
</div></section>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="zmqVersion"></a>nothrow @safe Tuple!(int, "major", int, "minor", int, "patch") zmqVersion();
</code></h1>
<p class="summary">Reports the &#x2205;MQ library version.
</p>
<section class="ddoc_section"><h1>Returns:</h1><div class="ddoc_paragraphs"> A <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> with three integer fields that represent the
    three versioning levels: <code>major</code>, <code>minor</code> and <code>patch</code>.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_version()">zmq_version()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Context"></a>struct Context;
</code></h1>
<p class="summary">An object that encapsulates a &#x2205;MQ context.
</p>
<div class="ddoc_paragraphs">In most programs, it is not necessary to use this type directly,
as <code><a href="#Socket">Socket</a></code> will use a default global context if not explicitly
provided with one.  See <code><a href="#defaultContext">defaultContext()</a></code> for details.
<br><br>

A default-initialized <code>Context</code> is not a valid &#x2205;MQ context; it
must always be explicitly initialized with <code><a href="#Context.opCall">Context.opCall()</a></code>:
<pre class="d_code">Context ctx;        <font color=green>// Not a valid context yet
</font>ctx = Context();    <font color=green>// ...but now it is.
</font></pre>
<code>Context</code> objects can be passed around by value, and two copies will
refer to the same context.  The underlying context is managed using
reference counting, so that when the last copy of a <code>Context</code> goes
out of scope, the context is automatically destroyed.

</div>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#defaultContext">defaultContext()</a></code></div></section>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Context.opCall"></a>static @safe Context opCall();
</code></h1>
<p class="summary">Creates a new &#x2205;MQ context.
</p>
<section class="ddoc_section"><h1>Returns:</h1><div class="ddoc_paragraphs"> A <code><a href="#Context">Context</a></code> object that encapsulates the new context.
</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_new()">zmq_ctx_new()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
<font color=blue>assert</font> (ctx.initialized);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Context.destroy"></a>@safe void destroy();
</code></h1>
<p class="summary">Destroys the &#x2205;MQ context.
</p>
<div class="ddoc_paragraphs">It is normally not necessary to do this manually, as the context will
    be destroyed automatically when the last reference to it goes out of
    scope.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy()">zmq_ctx_destroy()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
<font color=blue>assert</font> (ctx.initialized);
ctx.destroy();
<font color=blue>assert</font> (!ctx.initialized);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Context.ioThreads"></a>@property @safe int ioThreads();
<br><a name="Context.ioThreads"></a>@property @safe void ioThreads(int value);
</code></h1>
<p class="summary">The number of I/O threads.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_get()">zmq_ctx_get()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_ctx_set()">zmq_ctx_set()</a></code> with
        <code>ZMQ_IO_THREADS</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
ctx.ioThreads = 3;
<font color=blue>assert</font> (ctx.ioThreads == 3);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Context.maxSockets"></a>@property @safe int maxSockets();
<br><a name="Context.maxSockets"></a>@property @safe void maxSockets(int value);
</code></h1>
<p class="summary">The maximum number of sockets.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_ctx_get()">zmq_ctx_get()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_ctx_set()">zmq_ctx_set()</a></code> with
        <code>ZMQ_MAX_SOCKETS</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> ctx = Context();
ctx.maxSockets = 512;
<font color=blue>assert</font> (ctx.maxSockets == 512);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Context.handle"></a>inout pure nothrow @property @safe inout(void)* handle();
</code></h1>
<p class="summary">The <code>void*</code> pointer used by the underlying C API to refer to the context.
</p>
<div class="ddoc_paragraphs">If the object has not been initialized, this function returns <code><b>null</b></code>.</div>

</section>
<section class="member"><h1><code><a name="Context.initialized"></a>const pure nothrow @property @safe bool initialized();
</code></h1>
<p class="summary">Whether this <code><a href="#Context">Context</a></code> object has been initialized, i.e. whether it
    refers to a valid &#x2205;MQ context.</p>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
Context ctx;
<font color=blue>assert</font> (!ctx.initialized);
ctx = Context();
<font color=blue>assert</font> (ctx.initialized);
ctx.destroy();
<font color=blue>assert</font> (!ctx.initialized);
</pre>
</div></section>
</section>
</section>
</section>
<section class="member"><h1><code><a name="defaultContext"></a>@trusted Context defaultContext();
</code></h1>
<p class="summary">A global context which is used by default by all sockets, unless they are
explicitly constructed with a different context.
</p>
<div class="ddoc_paragraphs">The &#x2205;MQ Guide <a href="http://zguide.zeromq.org/page:all#Getting-the-Context-Right">has the following to say</a> about context creation:
<blockquote>   You should create and use exactly one context in your process.
    [&hellip;] If at runtime a process has two contexts, these are
    like separate &#x2205;MQ instances. If that's explicitly what you
    want, OK, but otherwise remember: <em>Do one <code>zmq_ctx_new()</code>
    at the start of your main line code, and one <code>zmq_ctx_destroy()</code>
    at the end.</em>
</blockquote>
By using <code>defaultContext()</code>, this is exactly what you achieve.  The
context is created the first time the function is called, and is
automatically destroyed when the program ends.
<br><br>

This function is thread safe.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#Context">Context</a></code></div></section>

</section>
<section class="member"><h1><code><a name="SocketType"></a>enum SocketType: int;
</code></h1>
<p class="summary">The various socket types.
</p>
<div class="ddoc_paragraphs">These are described in the <code><a href="http://api.zeromq.org/3-2:zmq_socket()">zmq_socket()</a></code> reference.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="SocketType.req"></a>req</code></h1>
<p class="summary">Corresponds to <code>ZMQ_REQ</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.rep"></a>rep</code></h1>
<p class="summary">Corresponds to <code>ZMQ_REP</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.dealer"></a>dealer</code></h1>
<p class="summary">Corresponds to <code>ZMQ_DEALER</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.router"></a>router</code></h1>
<p class="summary">Corresponds to <code>ZMQ_ROUTER</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.pub"></a>pub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.sub"></a>sub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_SUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.xpub"></a>xpub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_XPUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.xsub"></a>xsub</code></h1>
<p class="summary">Corresponds to <code>ZMQ_XSUB</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.push"></a>push</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PUSH</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.pull"></a>pull</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PULL</code></p>

</section>
<section class="member"><h1><code><a name="SocketType.pair"></a>pair</code></h1>
<p class="summary">Corresponds to <code>ZMQ_PAIR</code></p>

</section>
</section>
</section>
<section class="member"><h1><code><a name="Socket"></a>struct Socket;
</code></h1>
<p class="summary">An object that encapsulates a &#x2205;MQ socket.
</p>
<div class="ddoc_paragraphs">A default-initialized <code>Socket</code> is not a valid &#x2205;MQ socket; it
must always be explicitly initialized with a constructor (see
<code><a href="#Socket.this">Socket.this()</a></code>):
<pre class="d_code">Socket s;                     <font color=green>// Not a valid socket yet
</font>s = Socket(SocketType.push);  <font color=green>// ...but now it is.
</font></pre>
<code>Socket</code> objects can be passed around by value, and two copies will
refer to the same socket.  The underlying socket is managed using
reference counting, so that when the last copy of a <code>Socket</code> goes
out of scope, the socket is automatically closed.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Socket.this"></a> this(SocketType type);
<br><a name="Socket.this"></a> this(Context context, SocketType type);
</code></h1>
<p class="summary">Creates a new &#x2205;MQ socket.
</p>
<div class="ddoc_paragraphs">If <code>context</code> is not specified, the default context (as returned
    by <code><a href="#defaultContext">defaultContext()</a></code>) is used.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_socket()">zmq_socket()</a></code></div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> With default context:
<pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.push);
<font color=blue>assert</font> (sck.initialized);
</pre>
</div></section><section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> With explicit context:
<pre class="d_code">
<font color=blue>auto</font> ctx = Context();
<font color=blue>auto</font> sck = Socket(ctx, SocketType.push);
<font color=blue>assert</font> (sck.initialized);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.close"></a>@safe void close();
</code></h1>
<p class="summary">Closes the &#x2205;MQ socket.
</p>
<div class="ddoc_paragraphs">Note that the socket will be automatically closed when the last reference
    to it goes out of scope, so it is often not necessary to call this
    method manually.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_close()">zmq_close()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.pair);
<font color=blue>assert</font> (s.initialized);
s.close();
<font color=blue>assert</font> (!s.initialized);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.bind"></a>@safe void bind(const char[] endpoint);
</code></h1>
<p class="summary">Starts accepting incoming connections on <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_bind()">zmq_bind()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.pub);
s.bind(<font color=red>"inproc://zmqd_bind_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.unbind"></a>@safe void unbind(const char[] endpoint);
</code></h1>
<p class="summary">Stops accepting incoming connections on <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_unbind()">zmq_unbind()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.pub);
s.bind(<font color=red>"ipc://zmqd_unbind_example"</font>);
<font color=green>// Do some work...
</font>s.unbind(<font color=red>"ipc://zmqd_unbind_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.connect"></a>@safe void connect(const char[] endpoint);
</code></h1>
<p class="summary">Creates an outgoing connection to <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_connect()">zmq_connect()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.sub);
s.connect(<font color=red>"ipc://zmqd_connect_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.disconnect"></a>@safe void disconnect(const char[] endpoint);
</code></h1>
<p class="summary">Disconnects the socket from <code>endpoint</code>.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_disconnect()">zmq_disconnect()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s = Socket(SocketType.sub);
s.connect(<font color=red>"ipc://zmqd_disconnect_example"</font>);
<font color=green>// Do some work...
</font>s.disconnect(<font color=red>"ipc://zmqd_disconnect_example"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.send"></a>@safe void send(const ubyte[] data, bool more = false);
<br><a name="Socket.send"></a>@trusted void send(const char[] data, bool more = false);
<br><a name="Socket.trySend"></a>@safe bool trySend(const ubyte[] data, bool more = false);
<br><a name="Socket.trySend"></a>@trusted bool trySend(const char[] data, bool more = false);
</code></h1>
<p class="summary">Sends a message part.
</p>
<div class="ddoc_paragraphs"><code>send</code> blocks until the message has been queued on the socket.
    <code>trySend</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the message was queued on the
    socket.
<br><br>

    The <code>char[]</code> overload is a convenience function that simply casts
    the string argument to <code>ubyte[]</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_send()">zmq_send()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>trySend</code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.pub);
sck.send(<font color=blue>cast</font>(<font color=blue>ubyte</font>[]) [11, 226, 92]);
sck.send(<font color=red>"Hello World!"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.send"></a>@safe void send(ref Message msg, bool more = false);
<br><a name="Socket.trySend"></a>@safe bool trySend(ref Message msg, bool more = false);
</code></h1>
<p class="summary">Sends a message part.
</p>
<div class="ddoc_paragraphs"><code>send</code> blocks until the message has been queued on the socket.
    <code>trySend</code> performs the operation in non-blocking mode, and returns
    a <code>bool</code> value that signifies whether the message was queued on the
    socket.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_send()">zmq_msg_send()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>trySend</code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.pub);
<font color=blue>auto</font> msg = Message(12);
msg.data.asString()[] = <font color=red>"Hello World!"</font>;
sck.send(msg);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.receive"></a>@safe size_t receive(ubyte[] data);
<br><a name="Socket.tryReceive"></a>@safe Tuple!(size_t, bool) tryReceive(ubyte[] data);
</code></h1>
<p class="summary">Receives a message part.
</p>
<div class="ddoc_paragraphs"><code>receive</code> blocks until the request can be satisfied, and returns the
    number of bytes in the message.
    <code>tryReceive</code> performs the operation in non-blocking mode, and returns
    a <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> which contains the size of the message along
    with a <code>bool</code> value that signifies whether a message was received.
    (If the latter is <code><b>false</b></code>, the former is always set to zero.)

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_recv()">zmq_recv()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>tryReceive</code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Sender
</font><font color=blue>auto</font> snd = Socket(SocketType.req);
snd.connect(<font color=red>"ipc://zmqd_receive_example"</font>);
snd.send(<font color=red>"Hello World!"</font>);

<font color=green>// Receiver
</font><font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> rcv = Socket(SocketType.rep);
rcv.bind(<font color=red>"ipc://zmqd_receive_example"</font>);
<font color=blue>char</font>[256] buf;
<font color=blue>immutable</font> len  = rcv.receive(buf.representation);
<font color=blue>assert</font> (buf[0 .. len] == <font color=red>"Hello World!"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.receive"></a>@safe size_t receive(ref Message msg);
<br><a name="Socket.tryReceive"></a>@safe Tuple!(size_t, bool) tryReceive(ref Message msg);
</code></h1>
<p class="summary">Receives a message part.
</p>
<div class="ddoc_paragraphs"><code>receive</code> blocks until the request can be satisfied, and returns the
    number of bytes in the message.
    <code>tryReceive</code> performs the operation in non-blocking mode, and returns
    a <code><a href="http://dlang.org/phobos/std_typecons.html#.Tuple">std.typecons.Tuple</a></code> which contains the size of the message along
    with a <code>bool</code> value that signifies whether a message was received.
    (If the latter is <code><b>false</b></code>, the former is always set to zero.)

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_recv()">zmq_msg_recv()</a></code> (with the <code>ZMQ_DONTWAIT</code> flag, in the case
        of <code>tryReceive</code>).</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Sender
</font><font color=blue>auto</font> snd = Socket(SocketType.req);
snd.connect(<font color=red>"ipc://zmqd_msg_receive_example"</font>);
snd.send(<font color=red>"Hello World!"</font>);

<font color=green>// Receiver
</font><font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> rcv = Socket(SocketType.rep);
rcv.bind(<font color=red>"ipc://zmqd_msg_receive_example"</font>);
<font color=blue>auto</font> msg = Message();
rcv.receive(msg);
<font color=blue>assert</font> (msg.data.asString() == <font color=red>"Hello World!"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.type"></a>@property @safe SocketType type();
</code></h1>
<p class="summary">The socket type.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> with <code>ZMQ_TYPE</code>.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.xpub);
<font color=blue>assert</font> (sck.type == SocketType.xpub);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.more"></a>@property @safe bool more();
</code></h1>
<p class="summary">Whether there are more message data parts to follow.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> with <code>ZMQ_RCVMORE</code>.</div></section>

</section>
<section class="member"><h1><code><a name="Socket.sendHWM"></a>@property @safe int sendHWM();
<br><a name="Socket.sendHWM"></a>@property @safe void sendHWM(int value);
<br><a name="Socket.receiveHWM"></a>@property @safe int receiveHWM();
<br><a name="Socket.receiveHWM"></a>@property @safe void receiveHWM(int value);
<br><a name="Socket.threadAffinity"></a>@property @safe ulong threadAffinity();
<br><a name="Socket.threadAffinity"></a>@property @safe void threadAffinity(ulong value);
<br><a name="Socket.identity"></a>@property @trusted ubyte[] identity();
<br><a name="Socket.identity"></a>@property @safe void identity(const ubyte[] value);
<br><a name="Socket.identity"></a>@property @safe void identity(const char[] value);
<br><a name="Socket.rate"></a>@property @safe int rate();
<br><a name="Socket.rate"></a>@property @safe void rate(int value);
<br><a name="Socket.recoveryInterval"></a>@property @safe int recoveryInterval();
<br><a name="Socket.recoveryInterval"></a>@property @safe void recoveryInterval(int value);
<br><a name="Socket.sendBufferSize"></a>@property @safe int sendBufferSize();
<br><a name="Socket.sendBufferSize"></a>@property @safe void sendBufferSize(int value);
<br><a name="Socket.receiveBufferSize"></a>@property @safe int receiveBufferSize();
<br><a name="Socket.receiveBufferSize"></a>@property @safe void receiveBufferSize(int value);
<br><a name="Socket.linger"></a>@property @safe int linger();
<br><a name="Socket.linger"></a>@property @safe void linger(int value);
<br><a name="Socket.reconnectionInterval"></a>@property @safe int reconnectionInterval();
<br><a name="Socket.reconnectionInterval"></a>@property @safe void reconnectionInterval(int value);
<br><a name="Socket.maxReconnectionInterval"></a>@property @safe int maxReconnectionInterval();
<br><a name="Socket.maxReconnectionInterval"></a>@property @safe void maxReconnectionInterval(int value);
<br><a name="Socket.backlog"></a>@property @safe int backlog();
<br><a name="Socket.backlog"></a>@property @safe void backlog(int value);
<br><a name="Socket.maxMsgSize"></a>@property @safe long maxMsgSize();
<br><a name="Socket.maxMsgSize"></a>@property @safe void maxMsgSize(long value);
<br><a name="Socket.multicastHops"></a>@property @safe int multicastHops();
<br><a name="Socket.multicastHops"></a>@property @safe void multicastHops(int value);
<br><a name="Socket.receiveTimeout"></a>@property @safe int receiveTimeout();
<br><a name="Socket.receiveTimeout"></a>@property @safe void receiveTimeout(int value);
<br><a name="Socket.sendTimeout"></a>@property @safe int sendTimeout();
<br><a name="Socket.sendTimeout"></a>@property @safe void sendTimeout(int value);
<br><a name="Socket.ipv4Only"></a>@property @safe bool ipv4Only();
<br><a name="Socket.ipv4Only"></a>@property @safe void ipv4Only(bool value);
<br><a name="Socket.delayAttachOnConnect"></a>@property @safe bool delayAttachOnConnect();
<br><a name="Socket.delayAttachOnConnect"></a>@property @safe void delayAttachOnConnect(bool value);
<br><a name="Socket.fd"></a>@property @safe FD fd();
<br><a name="Socket.events"></a>@property @safe int events();
<br><a name="Socket.lastEndpoint"></a>@property @trusted char[] lastEndpoint();
</code></h1>
<p class="summary">Misc. socket properties.
</p>
<div class="ddoc_paragraphs">Each of these has a one-to-one correspondence with an option passed to
    <code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_setsockopt()">zmq_setsockopt()</a></code>. For
    example, <code>identity</code> corresponds to <code>ZMQ_IDENTITY</code>,
    <code>receiveBufferSize</code> corresponds to <code>ZMQ_RCVBUF</code>, etc.

</div>
<section class="ddoc_section"><h1>Notes:</h1><div class="ddoc_paragraphs">
    <ul>       <li>For convenience, the setter for the <code>identity</code> property
            accepts strings.  To retrieve a string with the getter, use
            the <code><a href="#asString">asString()</a></code> function.
<pre class="d_code">sck.identity = <font color=red>"foobar"</font>;
<font color=blue>assert</font> (sck.identity.asString() == <font color=red>"foobar"</font>);
</pre>
            </li>
        <li>The <code>fd</code> property is an <code>int</code> on POSIX and a <code>SOCKET</code>
            on Windows.</li>
        <li>The <code>ZMQ_SUBSCRIBE</code> and <code>ZMQ_UNSUBSCRIBE</code> options are
            treated differently from the others; see <code><a href="#Socket.subscribe">Socket.subscribe()</a></code>
            and <code><a href="#Socket.unsubscribe">Socket.unsubscribe()</a></code></li>
    </ul>

</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_getsockopt()">zmq_getsockopt()</a></code> and <code><a href="http://api.zeromq.org/3-2:zmq_setsockopt()">zmq_setsockopt()</a></code>.</div></section>

</section>
<section class="member"><h1><code><a name="Socket.subscribe"></a>@safe void subscribe(const ubyte[] filterPrefix);
<br><a name="Socket.subscribe"></a>@safe void subscribe(const char[] filterPrefix);
</code></h1>
<p class="summary">Establishes a message filter.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_setsockopt()">zmq_msg_setsockopt()</a></code> with <code>ZMQ_SUBSCRIBE</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Create a subscriber that accepts all messages that start with
</font><font color=green>// the prefixes "foo" or "bar".
</font><font color=blue>auto</font> sck = Socket(SocketType.sub);
sck.subscribe(<font color=red>"foo"</font>);
sck.subscribe(<font color=red>"bar"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.unsubscribe"></a>@safe void unsubscribe(const ubyte[] filterPrefix);
<br><a name="Socket.unsubscribe"></a>@safe void unsubscribe(const char[] filterPrefix);
</code></h1>
<p class="summary">Removes a message filter.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_setsockopt()">zmq_msg_setsockopt()</a></code> with <code>ZMQ_SUBSCRIBE</code>.</div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=green>// Subscribe to messages that start with "foo" or "bar".
</font><font color=blue>auto</font> sck = Socket(SocketType.sub);
sck.subscribe(<font color=red>"foo"</font>);
sck.subscribe(<font color=red>"bar"</font>);
<font color=green>// ...
</font><font color=green>// From now on, only accept messages that start with "bar"
</font>sck.unsubscribe(<font color=red>"foo"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Socket.monitor"></a>@safe void monitor(const char[] endpoint, EventType events = EventType.all);
</code></h1>
<p class="summary">Spawns a PAIR socket that publishes socket state changes (events) over
    the INPROC transport to the given endpoint.
</p>
<div class="ddoc_paragraphs">Which event types should be published may be selected by bitwise-ORing
    together different <code><a href="#EventType">EventType</a></code> flags in the <code>event</code> parameter.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_socket_monitor()">zmq_socket_monitor()</a></code>
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#receiveEvent">receiveEvent()</a></code>, which receives and parses event messages.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> sck = Socket(SocketType.pub);
sck.monitor(<font color=red>"inproc://zmqd_monitor_unittest"</font>,
            EventType.accepted | EventType.closed);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Socket.handle"></a>inout pure nothrow @property @safe inout(void)* handle();
</code></h1>
<p class="summary">The <code>void*</code> pointer used by the underlying C API to refer to the socket.
</p>
<div class="ddoc_paragraphs">If the object has not been initialized, this function returns <code><b>null</b></code>.</div>

</section>
<section class="member"><h1><code><a name="Socket.initialized"></a>const pure nothrow @property @safe bool initialized();
</code></h1>
<p class="summary">Whether this <code><a href="#Socket">Socket</a></code> object has been initialized, i.e. whether it
    refers to a valid &#x2205;MQ socket.</p>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
Socket sck;
<font color=blue>assert</font> (!sck.initialized);
sck = Socket(SocketType.sub);
<font color=blue>assert</font> (sck.initialized);
sck.close();
<font color=blue>assert</font> (!sck.initialized);
</pre>
</div></section>
</section>
</section>
</section>
<section class="member"><h1><code><a name="proxy"></a>nothrow @safe void proxy(ref Socket frontend, ref Socket backend);
<br><a name="proxy"></a>nothrow @safe void proxy(ref Socket frontend, ref Socket backend, ref Socket capture);
</code></h1>
<p class="summary">Starts the built-in &#x2205;MQ proxy.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_proxy()">zmq_proxy()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Message"></a>struct Message;
</code></h1>
<p class="summary">An object that encapsulates a &#x2205;MQ message.
</p>
<div class="ddoc_paragraphs">This <code>struct</code> is a wrapper around a <code>zmq_msg_t</code> object.  Unlike
<code><a href="#Context">Context</a></code> and <code><a href="#Socket">Socket</a></code>, it does <em>not</em> perform reference
counting, because &#x2205;MQ messages have a form of reference counting of
their own.  A <code>Message</code> cannot be copied by normal assignment; use
<code><a href="#Message.copy">Message.copy()</a></code> for this.
<br><br>

A default-initialized <code>Message</code> is not a valid &#x2205;MQ message; it
must always be explicitly initialized with <code><a href="#Message.opCall">Message.opCall()</a></code> or
<code><a href="#Message.this">Message.this()</a></code>:
<pre class="d_code">Message msg1;               <font color=green>// Invalid message
</font><font color=blue>auto</font> msg2 = Message();      <font color=green>// Empty message
</font><font color=blue>auto</font> msg3 = Message(1024);  <font color=green>// 1K message
</font></pre>
When a <code>Message</code> goes out of scope, <code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code> is
called on the underlying <code>zmq_msg_t</code>.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Message.opCall"></a>static @safe Message opCall();
</code></h1>
<p class="summary">Initialises an empty &#x2205;MQ message.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_init()">zmq_msg_init()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Message();
<font color=blue>assert</font>(msg.size == 0);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Message.this"></a> this(size_t size);
</code></h1>
<p class="summary">Initialises a &#x2205;MQ message of a specified size.
</p>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_init_size()">zmq_msg_init_size()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Message(123);
<font color=blue>assert</font>(msg.size == 123);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Message.close"></a>@safe void close();
</code></h1>
<p class="summary">Releases the &#x2205;MQ message.
</p>
<div class="ddoc_paragraphs">Note that the message will be automatically released when the <code>Message</code>
    object is destroyed, so it is often not necessary to call this method
    manually.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_close()">zmq_msg_close()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Message.copy"></a>@safe Message copy();
<br><a name="Message.copyTo"></a>@safe void copyTo(ref Message dest);
</code></h1>
<p class="summary">Copies message content to another message.
</p>
<div class="ddoc_paragraphs"><code>copy()</code> returns a new <code>Message</code> object, while <code>copyTo(dest)</code>
    copies the contents of this <code>Message</code> into <code>dest</code>.  <code>dest</code> must
    be a valid (i.e. initialised) <code>Message</code>.

</div>
<section class="ddoc_section"><h1>Warning:</h1><div class="ddoc_paragraphs">
These functions may not do what you think they do.  Please refer
        to <a href="http://api.zeromq.org/3-2:zmq_msg_copy()">the &#x2205;MQ manual</a> for details.
</div></section>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_copy()">zmq_msg_copy()</a></code></div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> msg1 = Message(3);
msg1.data[] = <font color=red>"foo"</font>.representation;
<font color=blue>auto</font> msg2 = msg1.copy();
<font color=blue>assert</font> (msg2.data.asString() == <font color=red>"foo"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Message.move"></a>@safe Message move();
<br><a name="Message.moveTo"></a>@safe void moveTo(ref Message dest);
</code></h1>
<p class="summary">Moves message content to another message.
</p>
<div class="ddoc_paragraphs"><code>move()</code> returns a new <code>Message</code> object, while <code>moveTo(dest)</code>
    moves the contents of this <code>Message</code> to <code>dest</code>.  <code>dest</code> must
    be a valid (i.e. initialised) <code>Message</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_move()">zmq_msg_move()</a></code></div></section>

<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> msg1 = Message(3);
msg1.data[] = <font color=red>"foo"</font>.representation;
<font color=blue>auto</font> msg2 = msg1.move();
<font color=blue>assert</font> (msg1.size == 0);
<font color=blue>assert</font> (msg2.data.asString() == <font color=red>"foo"</font>);
</pre>
</div></section></section>
<section class="member"><h1><code><a name="Message.size"></a>nothrow @property @safe size_t size();
</code></h1>
<p class="summary">The message content size in bytes.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_size()">zmq_msg_size()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> msg = Message(123);
<font color=blue>assert</font>(msg.size == 123);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Message.data"></a>nothrow @property @trusted ubyte[] data();
</code></h1>
<p class="summary">Retrieves the message content.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_data()">zmq_msg_data()</a></code></div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>import</font> std.string: representation;
<font color=blue>auto</font> msg = Message(3);
<font color=blue>assert</font>(msg.data.length == 3);
msg.data[] = <font color=red>"foo"</font>.representation; <font color=green>// Slice operator -&gt; array copy.
</font><font color=blue>assert</font>(msg.data.asString() == <font color=red>"foo"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="Message.more"></a>nothrow @property @safe bool more();
</code></h1>
<p class="summary">Whether there are more message parts to retrieve.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_msg_more()">zmq_msg_more()</a></code></div></section>

</section>
<section class="member"><h1><code><a name="Message.handle"></a>inout pure nothrow @property @safe inout(zmq_msg_t)* handle();
</code></h1>
<p class="summary">A pointer to the underlying <code>zmq_msg_t</code>.</p>

</section>
</section>
</section>
<section class="member"><h1><code><a name="EventType"></a>enum EventType: int;
</code></h1>
<p class="summary">Socket event types.
</p>
<div class="ddoc_paragraphs">These are used together with <code><a href="#Socket.monitor">Socket.monitor()</a></code>, and are described
in the <code><a href="http://api.zeromq.org/3-2:zmq_socket_monitor()">zmq_socket_monitor()</a></code> reference.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="EventType.connected"></a>connected</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CONNECTED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.connectDelayed"></a>connectDelayed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CONNECT_DELAYED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.connectRetried"></a>connectRetried</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CONNECT_RETRIED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.listening"></a>listening</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_LISTENING</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.bindFailed"></a>bindFailed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_BIND_FAILED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.accepted"></a>accepted</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_ACCEPTED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.acceptFailed"></a>acceptFailed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_ACCEPT_FAILED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.closed"></a>closed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CLOSED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.closeFailed"></a>closeFailed</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_CLOSE_FAILED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.disconnected"></a>disconnected</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_DISCONNECTED</code>.</p>

</section>
<section class="member"><h1><code><a name="EventType.all"></a>all</code></h1>
<p class="summary">Corresponds to <code>ZMQ_EVENT_ALL</code>.</p>

</section>
</section>
</section>
<section class="member"><h1><code><a name="receiveEvent"></a>@system Event receiveEvent(Socket socket);
</code></h1>
<p class="summary">Receives a message on the given socket and interprets it as a socket
state change event.
</p>
<div class="ddoc_paragraphs"><code>socket</code> must be a PAIR socket which is connected to an endpoint
created via a <code><a href="#Socket.monitor">Socket.monitor()</a></code> call.  <code>receiveEvent()</code> receives
one message on the socket, parses its contents according to the
specification in the <code><a href="http://api.zeromq.org/3-2:zmq_socket_monitor()">zmq_socket_monitor()</a></code> reference,
and returns the event information as an <code><a href="#Event">Event</a></code> object.
<br><br>

The function will attempt to detect whether the received message
is in fact an event message, by checking that its length is equal
to <code>zmq_event_t.sizeof</code> and that the value of the
<code>zmq_event_t.event</code> field is valid.  If this is not the case,
an <code><a href="#InvalidEventException">InvalidEventException</a></code> is thrown.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="#ZmqException">ZmqException</a></code> if &#x2205;MQ reports an error.<br>
    <code><a href="#InvalidEventException">InvalidEventException</a></code> if the received message could not
    be interpreted as an event message.
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#Socket.monitor">Socket.monitor()</a></code>, for monitoring socket state changes.</div></section>

</section>
<section class="member"><h1><code><a name="Event"></a>struct Event;
</code></h1>
<p class="summary">Information about a socket state change.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<a href="http://api.zeromq.org/3-2:zmq_socket_monitor"><code>zmq_event_t</code></a>
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="#receiveEvent">receiveEvent()</a></code></div></section>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="Event.type"></a>const pure nothrow @property @safe EventType type();
</code></h1>
<p class="summary">The event type.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.event</code></div></section>

</section>
<section class="member"><h1><code><a name="Event.address"></a>const pure nothrow @property @safe string address();
</code></h1>
<p class="summary">The peer address.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</div></section>

</section>
<section class="member"><h1><code><a name="Event.fd"></a>const pure nothrow @property @safe Socket.FD fd();
</code></h1>
<p class="summary">The socket file descriptor.
</p>
<div class="ddoc_paragraphs">This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is one of:
    <code>connected</code>, <code>listening</code>, <code>accepted</code>, <code>closed</code> or <code>disonnected</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code>Error</code> if the property is called for a wrong event type.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</div></section>

</section>
<section class="member"><h1><code><a name="Event.errno"></a>const pure nothrow @property @safe int errno();
</code></h1>
<p class="summary">The <code>errno</code> code for the error which triggered the event.
</p>
<div class="ddoc_paragraphs">This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is one of:
    <code>connectDelayed</code>, <code>bindFailed</code>, <code>acceptFailed</code> or <code>closeFailed</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code>Error</code> if the property is called for a wrong event type.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.xyz.addr</code>, where <code>xyz</code> is the event-specific union.</div></section>

</section>
<section class="member"><h1><code><a name="Event.interval"></a>const pure nothrow @property @safe int interval();
</code></h1>
<p class="summary">The socket file descriptor.
</p>
<div class="ddoc_paragraphs">This property function may only be called if <code><a href="#Event.type">Event.type</a></code> is
    <code>connectRetried</code>.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code>Error</code> if the property is called for a wrong event type.
</div></section>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code>zmq_event_t.data.connect_retried.interval</code></div></section>

</section>
</section>
</section>
<section class="member"><h1><code><a name="asString"></a>pure @safe inout(char)[] asString(inout(ubyte)[] data);
</code></h1>
<p class="summary">Utility function which interprets and validates a byte array as a UTF-8 string.
</p>
<div class="ddoc_paragraphs">Most of &#x2205;MQD's message API deals in <code>ubyte[]</code> arrays, but very often,
the message data contains plain text.  <code>asString()</code> allows for easy and
safe interpretation of raw data as characters.  It checks that <code>data</code> is
a valid UTF-8 encoded string, and returns a <code>char[]</code> array that refers to
the same memory region.

</div>
<section class="ddoc_section"><h1>Throws:</h1><div class="ddoc_paragraphs"> <code><a href="http://dlang.org/phobos/std_utf.html#.UTFException">std.utf.UTFException</a></code> if <code>data</code> is not a valid UTF-8 string.
</div></section>
<section class="ddoc_section"><h1>See also:</h1><div class="ddoc_paragraphs"> <code><a href="http://dlang.org/phobos/std_string.html#.representation">std.string.representation</a></code>, which performs the opposite operation.</div></section>
<section class="ddoc_section"><h1>Examples:</h1><div class="ddoc_paragraphs"> <pre class="d_code">
<font color=blue>auto</font> s1 = Socket(SocketType.pair);
s1.bind(<font color=red>"ipc://zmqd_asString_example"</font>);
<font color=blue>auto</font> s2 = Socket(SocketType.pair);
s2.connect(<font color=red>"ipc://zmqd_asString_example"</font>);

<font color=blue>auto</font> msg = Message(12);
msg.data.asString()[] = <font color=red>"Hello World!"</font>;
s1.send(msg);

<font color=blue>ubyte</font>[12] buf;
s2.receive(buf);
<font color=blue>assert</font>(buf.asString() == <font color=red>"Hello World!"</font>);
</pre>
</div></section>
</section>
<section class="member"><h1><code><a name="ZmqException"></a>class ZmqException: object.Exception;
</code></h1>
<p class="summary">A class for exceptions thrown when any of the underlying &#x2205;MQ C functions
report an error.
</p>
<div class="ddoc_paragraphs">The exception provides a standard error message obtained with
<code><a href="http://api.zeromq.org/3-2:zmq_strerror()">zmq_strerror()</a></code>, as well as the <code>errno</code> code set by the &#x2205;MQ
function which reported the error.</div>

<section class="members"><h1>Members</h1><section class="member"><h1><code><a name="ZmqException.errno"></a>immutable int errno;
</code></h1>
<p class="summary">The <code>errno</code> code that was set by the &#x2205;MQ function that reported
    the error.
</p>
<section class="ddoc_section"><h1>Corresponds to:</h1><div class="ddoc_paragraphs">
<code><a href="http://api.zeromq.org/3-2:zmq_errno()">zmq_errno()</a></code></div></section>

</section>
</section>
</section>
<section class="member"><h1><code><a name="InvalidEventException"></a>class InvalidEventException: object.Exception;
</code></h1>
<p class="summary">Exception thrown by <code><a href="#receiveEvent">receiveEvent()</a></code> on failure to interpret a
received message as an event description.</p>

</section>
</section>

                <footer>
                    <div class="ddoc_paragraphs">Copyright (c) 20132014, Lars T. Kyllingstad. All rights reserved.
</div>
                    <p>This documentation was generated on Sun Feb  9 19:36:41 2014
 with
                       <a href="https://github.com/kyllingstad/ltkdoc">LTKdoc 0.1</a>.</p>
                </footer>
            </section>
        </body>
    </html>
